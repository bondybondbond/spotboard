console.log("üöÄ SpotBoard: Content Script Loaded");

// Debug mode - set to true for detailed logging
const DEBUG = false;
const log = (...args: any[]) => DEBUG && console.log(...args);

let isCapturing = false;
let lockedElement: HTMLElement | null = null; // Track element waiting for confirmation
let excludedElements: HTMLElement[] = []; // Track child elements marked for exclusion (red)


// Check if an ID looks auto-generated and should be avoided
function isAutoGeneratedId(id: string): boolean {
  if (!id) return false;
  
  // Patterns for auto-generated IDs:
  // - Starts with "yui_" (Yahoo UI framework)
  // - Contains long sequences of numbers (10+ digits, likely timestamps)
  // - Contains UUID patterns (hex-hex-hex-hex-hex)
  // - React/Vue generated IDs
  const patterns = [
    /^yui_/i,                    // Yahoo UI: yui_3_18_1_1_1764458743229_1180
    /\d{10,}/,                   // Long numbers (timestamps): id_1234567890123
    /[a-f0-9]{8}-[a-f0-9]{4}/i,  // UUID-like: 12345678-1234-...
    /^react-/i,                  // React: react-select-2-option-1
    /^__BVID__/i,                // Vue Bootstrap
    /^ember\d+/i                 // Ember: ember123
  ];
  
  return patterns.some(pattern => pattern.test(id));
}

// Generate a specific CSS selector for an element
function generateSelector(element: HTMLElement): string {
  log('üéØ Starting selector generation for:', element.tagName, element.className);
  
  // Priority 1: ID (only if NOT auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    log('‚úÖ Found stable ID selector:', `#${element.id}`);
    return `#${element.id}`;
  } else if (element.id && isAutoGeneratedId(element.id)) {
    log('‚ö†Ô∏è Skipping auto-generated ID:', element.id);
  }
  
  // Build base selector: tag + classes + data attributes
  let baseSelector = buildBaseSelector(element);
  log('üìã Base selector:', baseSelector);
  
  // Check if selector is unique on the page
  const matches = document.querySelectorAll(baseSelector);
  log(`üîç Base selector matches ${matches.length} elements`);
  
  if (matches.length === 1) {
    log('üéØ Generated unique selector:', baseSelector);
    return baseSelector;
  }
  
  log(`‚ö†Ô∏è Selector "${baseSelector}" matches ${matches.length} elements, adding context...`);
  
  // For very generic selectors, go straight to path-based approach
  if (baseSelector === element.tagName.toLowerCase() && matches.length > 50) {
    log('üî§ Element is too generic, skipping to path-based selector...');
  }
  
  // Not unique - try adding nth-of-type
  const parent = element.parentElement;
  if (parent) {
    const siblings = Array.from(parent.children).filter(
      child => child.matches(baseSelector.split('[')[0]) // Match by tag.class without attrs
    );
    const index = siblings.indexOf(element) + 1;
    
    if (index > 0) {
      const nthSelector = `${baseSelector}:nth-of-type(${index})`;
      const nthMatches = document.querySelectorAll(nthSelector);
      log(`üîç nth-of-type selector matches ${nthMatches.length} elements`);
      
      if (nthMatches.length === 1) {
        log('üéØ Generated unique selector with nth-of-type:', nthSelector);
        return nthSelector;
      }
    }
  }
  
  // Still not unique - build path from unique ancestor
  const pathSelector = buildPathFromUniqueAncestor(element, baseSelector);
  if (pathSelector) {
    log('üéØ Generated unique selector with ancestor path:', pathSelector);
    return pathSelector;
  }
  
  // üö® CRITICAL: Never return ultra-generic selectors (bare tag names)
  // These will match TOO MANY elements during refresh and cause content removal
  const isBareTag = /^[a-z]+$/i.test(baseSelector); // Just a tag name like "div", "span", "a"
  
  if (isBareTag) {
    log('üö® BLOCKING ultra-generic selector:', baseSelector);
    // Force path-based approach by adding parent context
    const parent = element.parentElement;
    if (parent) {
      const parentBase = buildBaseSelector(parent);
      const contextSelector = `${parentBase} > ${baseSelector}`;
      log('‚úÖ Adding parent context:', contextSelector);
      return contextSelector;
    }
  }
  
  // Last resort: return base selector (fingerprint will catch mismatches)
  log('‚ö†Ô∏è Could not make selector unique, using:', baseSelector);
  return baseSelector;
}

// Helper: Escape special characters in CSS class names (for Tailwind etc.)
function escapeCSSClass(className: string): string {
  // Escape special characters that are invalid in CSS selectors
  // Common in Tailwind: : / [ ] ( ) @ ! # $ % ^ & * + = , . < > ? ~ 
  return className
    .replace(/:/g, '\\:')   // xl:mt-0 -> xl\:mt-0
    .replace(/\//g, '\\/')  // w-3/12 -> w-3\/12
    .replace(/\[/g, '\\[')  // [&_svg] -> \[&_svg\]
    .replace(/\]/g, '\\]')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)')
    .replace(/\./g, '\\.')  // Important: escape dots in class names
    .replace(/#/g, '\\#')
    .replace(/!/g, '\\!')
    .replace(/@/g, '\\@')
    .replace(/\$/g, '\\$')
    .replace(/%/g, '\\%')
    .replace(/\^/g, '\\^')
    .replace(/&/g, '\\&')
    .replace(/\*/g, '\\*')
    .replace(/\+/g, '\\+')
    .replace(/=/g, '\\=')
    .replace(/,/g, '\\,')
    .replace(/</g, '\\<')
    .replace(/>/g, '\\>')
    .replace(/\?/g, '\\?')
    .replace(/~/g, '\\~');
}

// Helper: Build base selector (tag + classes + data attrs)
function buildBaseSelector(element: HTMLElement): string {
  let selector = element.tagName.toLowerCase();
  
  // Add classes (max 3 to avoid overly specific selectors)
  if (element.classList.length > 0) {
    const classes = Array.from(element.classList)
      .filter(c => !c.includes('hover') && !c.includes('active')) // Skip state classes
      .slice(0, 3)
      .map(c => escapeCSSClass(c)); // ‚ú® ESCAPE SPECIAL CHARACTERS
    if (classes.length > 0) {
      selector += '.' + classes.join('.');
    }
  }
  
  // Add key data attributes (very useful for modern sites like BBC)
  const usefulAttrs = ['data-testid', 'data-test', 'data-component', 'data-section', 'data-module', 'data-type', 'data-t', 'role'];
  for (const attr of usefulAttrs) {
    if (element.hasAttribute(attr)) {
      const value = element.getAttribute(attr);
      selector += `[${attr}="${value}"]`;
      break; // One data attr is usually enough
    }
  }
  
  return selector;
}

// Helper: Walk up DOM to find unique ancestor, build path
function buildPathFromUniqueAncestor(element: HTMLElement, baseSelector: string): string | null {
  let current = element.parentElement;
  const pathParts: string[] = [baseSelector];
  
  while (current && current.tagName !== 'BODY' && current.tagName !== 'HTML') {
    // Check if this ancestor has an ID
    if (current.id) {
      pathParts.unshift(`#${current.id}`);
      const fullPath = pathParts.join(' > ');
      if (document.querySelectorAll(fullPath).length === 1) {
        return fullPath;
      }
    }
    
    // Check for unique data attributes on ancestor
    const usefulAttrs = ['data-testid', 'data-component', 'data-section', 'data-module', 'data-type'];
    for (const attr of usefulAttrs) {
      if (current.hasAttribute(attr)) {
        const ancestorSelector = `${current.tagName.toLowerCase()}[${attr}="${current.getAttribute(attr)}"]`;
        pathParts.unshift(ancestorSelector);
        const fullPath = pathParts.join(' > ');
        if (document.querySelectorAll(fullPath).length === 1) {
          return fullPath;
        }
        pathParts.shift(); // Remove if not unique
      }
    }
    
    // Add parent to path and continue up
    const parentSelector = buildBaseSelector(current);
    pathParts.unshift(parentSelector);
    
    // Check if path is now unique
    const fullPath = pathParts.join(' > ');
    if (document.querySelectorAll(fullPath).length === 1) {
      return fullPath;
    }
    
    // Limit depth to avoid overly long selectors
    if (pathParts.length > 4) {
      break;
    }
    
    current = current.parentElement;
  }
  
  return null;
}

// 1. Hover Handler (The Red Box)
function handleHover(event: MouseEvent) {
  if (!isCapturing) return;
  
  const target = event.target as HTMLElement;
  
  // FIRST: Don't touch modal at all - this must come before ANY other logic
  if (target.closest('#spotboard-capture-confirmation')) {
    return;
  }
  
    
  if (lockedElement) {
        
    // Keep green outline on locked element
    lockedElement.style.setProperty('outline', '5px solid #00ff00', 'important');
    
    // Check if hovering over a child of locked element (but not the locked element itself)
    if (lockedElement.contains(target) && target !== lockedElement) {
      // Check if this element is already excluded
      const isAlreadyExcluded = excludedElements.includes(target);
      
      if (isAlreadyExcluded) {
        // Keep the solid red styling for already-excluded elements
        target.style.setProperty('background', 'rgba(255, 0, 0, 0.3)', 'important');
        target.style.setProperty('outline', '2px solid #ff0000', 'important');
      } else {
        // Show dashed red border preview for potential exclusion
        target.style.setProperty('outline', '2px dashed #ff0000', 'important');
        target.style.setProperty('background', 'transparent', 'important');
      }
      target.style.cursor = 'pointer';
    }
    
    return;
  }
  
  // Normal capture mode: show red outline for element selection
  target.style.setProperty('outline', '5px solid red', 'important');
  target.style.cursor = 'crosshair';
  
  event.stopPropagation();
}

// 2. Exit Handler (Cleanup)
function handleExit(event: MouseEvent) {
  if (!isCapturing) return;
  const target = event.target as HTMLElement;
  
  // FIRST: Don't touch modal at all
  if (target.closest('#spotboard-capture-confirmation')) {
    return;
  }
  
  // If in exclusion mode (element locked)
  if (lockedElement) {
    // Don't clear styling from locked element or already-excluded elements
    if (target === lockedElement || excludedElements.includes(target)) {
      return;
    }
    // Clear preview styling from non-excluded children
    target.style.removeProperty('outline');
    target.style.removeProperty('background');
    return;
  }
  
  // Normal mode: clear hover styling
  target.style.outline = '';
}

// 3. Click Handler (The Save)
// Sanitize captured HTML - remove capture artifacts
// Show styled notification modal instead of alert
function showStyledNotification(message: string, type: 'success' | 'error' = 'success') {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999999;
  `;
  
  const modalContent = document.createElement('div');
  const bgColor = type === 'success' ? '#2d3748' : '#742a2a';
  modalContent.style.cssText = `
    background: ${bgColor};
    color: white;
    padding: 24px;
    border-radius: 8px;
    max-width: 400px;
    width: 90%;
    text-align: center;
  `;
  
  modalContent.innerHTML = `
    <div style="font-size: 16px; margin-bottom: 20px; line-height: 1.5;">
      ${message}
    </div>
    <button id="closeNotification" style="width: 100%; padding: 12px; background: #4299e1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">
      OK
    </button>
  `;
  
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // Close modal handlers
  const closeBtn = modal.querySelector('#closeNotification');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.remove());
  }
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

function sanitizeHTML(element: HTMLElement, excludedElements: HTMLElement[] = []): string {
  console.log('üßπ sanitizeHTML called with', excludedElements.length, 'excluded elements');
  
  // üéØ STEP 1: Mark hidden elements in ORIGINAL DOM (before cloning)
  // Check computed styles on live DOM elements, then mark them for removal
  const allOriginalElements = [element, ...Array.from(element.querySelectorAll('*'))];
  const markedElements: HTMLElement[] = [];
  
  // Get the captured element's bounding rect for relative position checking
  const containerRect = element.getBoundingClientRect();
  
  // Helper: Find nearest ancestor that clips content (carousel container)
  const findClippingAncestor = (el: HTMLElement): DOMRect => {
    let parent = el.parentElement;
    while (parent && parent !== element) {
      const style = window.getComputedStyle(parent);
      // Check all overflow values that cause clipping
      const overflowX = style.overflowX;
      const overflow = style.overflow;
      const isClipping = 
        overflow === 'hidden' || overflow === 'scroll' || overflow === 'auto' || overflow === 'clip' ||
        overflowX === 'hidden' || overflowX === 'scroll' || overflowX === 'auto' || overflowX === 'clip';
      
      if (isClipping) {
        const parentRect = parent.getBoundingClientRect();
        // Only use this container if it's narrower than our current reference (actual clipping)
        // and reasonably sized (not a tiny element)
        if (parentRect.width < containerRect.width && parentRect.width > 50) {
          return parentRect;
        }
      }
      parent = parent.parentElement;
    }
    return containerRect; // Fallback to outer container
  };
  
  
  allOriginalElements.forEach(el => {
    if (el instanceof HTMLElement && el !== element) {
      const computed = window.getComputedStyle(el);
      
      // üéØ COMPREHENSIVE VISIBILITY CHECK
      // Method 1: CSS-based hiding
      const isDisplayNone = computed.display === 'none';
      const isVisibilityHidden = computed.visibility === 'hidden';
      const isOpacityZero = computed.opacity === '0';
      const isAriaHidden = el.getAttribute('aria-hidden') === 'true';
      
      // Method 2: Off-screen positioning (carousel slides)
      // Use the nearest clipping ancestor (overflow:hidden) for bounds check
      const rect = el.getBoundingClientRect();
      const clipRect = findClippingAncestor(el);
      const isOffScreenLeft = rect.right < clipRect.left;   // Fully left of clip container
      const isOffScreenRight = rect.left > clipRect.right;  // Fully right of clip container
      const isOffScreen = isOffScreenLeft || isOffScreenRight;
      
      const isHidden = isDisplayNone || isVisibilityHidden || isOpacityZero || isAriaHidden || isOffScreen;
      
      if (isHidden) {
        el.setAttribute('data-spotboard-hidden', 'true');
        markedElements.push(el);
      }
    }
  });

  // üéØ IMAGE CONTEXT CLASSIFICATION (BEFORE CLONING)
  // 5-tier system based on rendered size and container ratio:
  // Icon (25px): Tiny images like logos, avatars, voting buttons
  // Small (48px): Avatars, badges
  // Thumbnail (80px): HotUK style deal images
  // Medium (100px): Zoopla property images (landscape)
  // Preview (150px): Large product hero images
  element.querySelectorAll('img').forEach(img => {
    try {
      // Get nearest structural container (article, section, or direct parent)
      let container = img.closest('article, section') || img.parentElement;
      if (!container) {
        console.log('  ‚ö†Ô∏è Image has no container, defaulting to icon');
        img.setAttribute('data-scale-context', 'icon');
        return;
      }
      
      // Calculate container dimensions (works because element is in DOM)
      const containerRect = container.getBoundingClientRect();
      const containerArea = containerRect.width * containerRect.height;
      
      // Calculate RENDERED image dimensions
      const imgRect = img.getBoundingClientRect();
      const imageArea = imgRect.width * imgRect.height;
      const imgHeight = imgRect.height;
      
      // Calculate area ratio
      const areaRatio = containerArea > 0 ? imageArea / containerArea : 0;
      
      // 5-tier classification logic (HEIGHT-BASED primary)
      let context: 'icon' | 'small' | 'thumbnail' | 'medium' | 'preview';
      
      // Rule 1: Tiny images (<40px height) = icon (25px)
      if (imgHeight < 40 || imageArea < 1600) {
        context = 'icon';
      }
      // Rule 2: Small images (<70px height) = small (48px)
      else if (imgHeight < 70 || imageArea < 4900) {
        context = 'small';
      }
      // Rule 3: Small ratio (<10%) = small (48px) - decorative
      else if (areaRatio < 0.10) {
        context = 'small';
      }
      // Rule 4: Medium ratio (10-25%) = thumbnail (80px)
      else if (areaRatio < 0.25 || imageArea < 15000) {
        context = 'thumbnail';
      }
      // Rule 5: Medium-large ratio (25-50%) = medium (100px)
      else if (areaRatio < 0.50 || imageArea < 40000) {
        context = 'medium';
      }
      // Rule 6: Large ratio (>50%) AND large area = preview (150px)
      else {
        context = 'preview';
      }
      
      img.setAttribute('data-scale-context', context);
      
    } catch (e) {
      console.warn('  ‚ö†Ô∏è Failed to classify image, defaulting to icon:', e);
      img.setAttribute('data-scale-context', 'icon');
    }
  });
  


  // Clone (classification attributes will be copied)
  const clone = element.cloneNode(true) as HTMLElement;
  
  // Clean up markers from original DOM (restore page to pristine state)
  markedElements.forEach(el => el.removeAttribute('data-spotboard-hidden'));
  
  // üéØ REMOVE USER-EXCLUDED ELEMENTS
  // User marked these elements for exclusion before confirming capture
  // We need to find them in the clone using path-based matching
  if (excludedElements.length > 0) {
    console.log('üéØ Processing', excludedElements.length, 'user-excluded elements');
    
    // For each excluded element, calculate its path from root
    // Then find the same element in the clone using that path
    excludedElements.forEach(excludedEl => {
      // Get path from root element to excluded element
      const path = getElementPath(excludedEl, element);
      console.log('  üìç Excluded element path:', path, excludedEl.tagName, excludedEl.className);
      
      // Find corresponding element in clone using path
      const elementInClone = getElementByPath(clone, path);
      
      if (elementInClone) {
        elementInClone.remove();
        console.log('  ‚úÖ Removed excluded element from clone');
      } else {
        console.warn('  ‚ö†Ô∏è Could not find excluded element in clone');
      }
    });
  }
  
  // üéØ HIT LIST: Remove known duplicate/hidden elements by class name
  // This fixes mobile/desktop duplicate content patterns across sites
  // Modern responsive sites include BOTH mobile and desktop content in DOM, hiding one with CSS
  // Common pattern: Full version (desktop) + Short version (mobile) = duplicates in capture
  // Note: BBC uses CSS-in-JS class names like "ssrcss-xxx-MobileValue", so we use partial match
  const duplicateSelectors = [
    // Screen reader / accessibility (always hidden)
    '.visually-hidden',           // Screen reader text (exact class)
    '.sr-only',                   // Bootstrap screen reader
    '[class*="VisuallyHidden"]',  // BBC visually hidden (partial match)
    
    // Mobile-specific content (hidden on desktop)
    '[class*="MobileValue"]',     // BBC mobile duplicate (partial match for CSS-in-JS)
    '[class*="-mobile"]',         // Generic mobile classes (e.g., "content-mobile", "title-mobile")
    '[class*="mobile-"]',         // Generic mobile classes (e.g., "mobile-content", "mobile-title")
    
    // Shortened/abbreviated content (mobile versions)
    '[class*="-short"]',          // Generic short classes (e.g., "team-name--short", "title-short")
    '[class*="short-"]',          // Generic short classes (e.g., "short-title", "short-name")
    '[class*="team-name--short"]',// Premier League mobile team names (duplicate)
    '[class*="team-name--abbr"]', // Generic abbreviated team names (backup pattern)
    '[class*="-abbr"]',           // Generic abbreviation classes (e.g., "name-abbr", "title-abbr")
    '[class*="abbreviated"]',     // Explicit abbreviated content
    
    // üéØ CAROUSEL/GALLERY UI CONTROLS (always remove - not content)
    // These are navigation elements that clutter the dashboard
    '[class*="navigate"]',        // Rightmove: ImagesControls_navigateButtons__
    '[class*="NavigateButton"]',  // Generic navigate buttons
    '[class*="previousButton"]',  // Rightmove: ImagesControls_previousButton__
    '[class*="nextButton"]',      // Rightmove: ImagesControls_nextButton__
    '[class*="prevButton"]',      // Generic prev buttons
    '[class*="Chevron"]',         // Rightmove: ImagesControls_previousChevron__
    '[class*="chevron"]',         // Generic chevron icons
    '[class*="carousel-control"]',// Bootstrap carousel controls
    '[class*="slick-arrow"]',     // Slick slider arrows
    '[class*="swiper-button"]',   // Swiper slider buttons
    '[class*="gallery-nav"]',     // Generic gallery navigation
    '[class*="slider-nav"]',      // Generic slider navigation
    '[class*="slide-arrow"]',     // Generic slide arrows
    'button[aria-label*="previous"]', // Accessibility-labeled prev buttons
    'button[aria-label*="next"]',     // Accessibility-labeled next buttons
    'button[aria-label*="arrow"]',    // Arrow buttons by aria-label
    '[class*="ImageControls"]',   // Rightmove variant
    '[class*="image-controls"]',  // Generic image controls
    '[class*="Controls_"]'        // CSS module controls pattern
  ];
  duplicateSelectors.forEach(selector => {
    clone.querySelectorAll(selector).forEach(el => el.remove());
  });

  // üéØ Remove elements with display:none (catches CSS-based hidden duplicates)
  // The Verge and other sites use CSS-in-JS classes where mobile/desktop versions
  // are differentiated by computed display style rather than class keywords
  // Strategy: Mark hidden elements in ORIGINAL DOM before cloning, then remove from clone
  const hiddenInClone = clone.querySelectorAll('[data-spotboard-hidden="true"]');
  hiddenInClone.forEach(el => el.remove());

  // Remove capture-related inline styles from clone
  const cloneElements = [clone, ...Array.from(clone.querySelectorAll('*'))];
  cloneElements.forEach(el => {
    if (el instanceof HTMLElement) {
      el.style.removeProperty('cursor');
      el.style.removeProperty('outline');
      if (el.style.length === 0) {
        el.removeAttribute('style');
      }
    }
  });
  
  // üéØ FIX PROGRESSIVE LOADING IMAGES: Remove loading artifacts
  // Sites use progressive loading: blur filters, skeleton loaders, lazy loading
  // These break in dashboard because JavaScript that removes them doesn't run
  clone.querySelectorAll('img').forEach(img => {
    // Remove lazy loading attribute
    img.removeAttribute('loading');
    
    // Remove progressive loading classes that cause blur/skeleton effects
    // SlotCatalog: .blurring (filter: blur(4px))
    // Others: .skeleton, .loading, .placeholder, .lazy
    const loadingClasses = ['blurring', 'skeleton', 'loading', 'placeholder', 'lazy', 'lazy-load'];
    loadingClasses.forEach(cls => {
      if (img.classList.contains(cls)) {
        img.classList.remove(cls);
      }
    });
  });
  
  // üéØ FIX LAZY-LOADED IMAGES: Convert data-image/data-src to src
  // Epic Games, many modern sites use data-image, data-src, data-lazy-src for lazy loading
  // These need to be swapped to src before we capture, otherwise images are blank placeholders
  clone.querySelectorAll('img').forEach(img => {
    // Common lazy-load attribute names (in priority order)
    const lazyAttrs = ['data-image', 'data-src', 'data-lazy-src', 'data-original', 'data-lazy'];
    
    for (const attr of lazyAttrs) {
      const lazyUrl = img.getAttribute(attr);
      if (lazyUrl && lazyUrl.startsWith('http')) {
        // Found a real URL in lazy attribute - use it as src
        img.setAttribute('src', lazyUrl);
        break; // Stop after first match
      }
    }
  });
  
  // üéØ FIX RELATIVE URLS: Convert ALL relative URLs to absolute
  // Prevents resources from being resolved to chrome-extension:// origin
  const pageUrl = window.location.href;
  
  // Fix image src attributes
  clone.querySelectorAll('img[src]').forEach(img => {
    const src = img.getAttribute('src');
    
    // üîß Handle protocol-relative URLs (//upload.wikimedia.org/...)
    if (src && src.startsWith('//')) {
      img.setAttribute('src', 'https:' + src);
      return;
    }
    
    if (src && !src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('blob:')) {
      try {
        const absoluteUrl = new URL(src, pageUrl).href;
        img.setAttribute('src', absoluteUrl);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix img src:', src, e);
      }
    }
  });
  
  // Fix image srcset attributes (for responsive images)
  clone.querySelectorAll('img[srcset]').forEach(img => {
    const srcset = img.getAttribute('srcset');
    if (srcset) {
      try {
        const fixedSrcset = srcset.split(',').map(src => {
          const parts = src.trim().split(/\s+/);
          const url = parts[0];
          
          // üîß Handle protocol-relative URLs (//upload.wikimedia.org/...)
          if (url && url.startsWith('//')) {
            parts[0] = 'https:' + url;
            return parts.join(' ');
          }
          
          if (url && !url.startsWith('http') && !url.startsWith('data:') && !url.startsWith('blob:')) {
            const absoluteUrl = new URL(url, pageUrl).href;
            parts[0] = absoluteUrl;
          }
          return parts.join(' ');
        }).join(', ');
        img.setAttribute('srcset', fixedSrcset);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix img srcset:', e);
      }
    }
  });
  
  // Fix link hrefs (so they stay clickable)
  clone.querySelectorAll('a[href]').forEach(link => {
    const href = link.getAttribute('href');
    if (href && !href.startsWith('#') && !href.startsWith('javascript:') && !href.startsWith('mailto:') && !href.startsWith('tel:') && !href.startsWith('http')) {
      try {
        const absoluteUrl = new URL(href, pageUrl).href;
        link.setAttribute('href', absoluteUrl);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix link href:', href, e);
      }
    }
  });
  
  // Fix CSS background images in inline styles
  clone.querySelectorAll('[style]').forEach(el => {
    const style = (el as HTMLElement).getAttribute('style');
    if (style && style.includes('url(')) {
      try {
        const fixedStyle = style.replace(/url\(['"]?([^'"()]+)['"]?\)/g, (match, url) => {
          if (url.startsWith('data:') || url.startsWith('blob:') || url.startsWith('http')) {
            return match;
          }
          try {
            const absoluteUrl = new URL(url, pageUrl).href;

            return `url('${absoluteUrl}')`;
          } catch (e) {
            return match;
          }
        });
        (el as HTMLElement).setAttribute('style', fixedStyle);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix CSS background:', e);
      }
    }
  });
  
  return clone.outerHTML;
}

// Helper: Get path from root to element
function getElementPath(element: Element, root: Element): number[] {
  const path: number[] = [];
  let current = element;
  
  while (current && current !== root) {
    const parent = current.parentElement;
    if (!parent) break;
    
    const index = Array.from(parent.children).indexOf(current);
    path.unshift(index);
    current = parent;
  }
  
  return path;
}

// Helper: Get element from clone using path
function getElementByPath(root: Element, path: number[]): Element | null {
  let current: Element | null = root;
  
  for (const index of path) {
    if (!current) return null;
    current = current.children[index] || null;
  }
  
  return current;
}


// Toggle exclusion marking on child element

// Clear all exclusion markings and reset array
function resetExclusions() {
  // Remove red markings from all excluded elements
  excludedElements.forEach(el => {
    el.style.removeProperty('background');
    el.style.removeProperty('outline');
  });
  // Clear the array
  excludedElements = [];
  log('üßπ All exclusions cleared');
}

function toggleExclusion(element: HTMLElement) {
  const isExcluded = excludedElements.includes(element);
  
  if (isExcluded) {
    // Remove from excluded list and remove red marking
    excludedElements = excludedElements.filter(el => el !== element);
    element.style.removeProperty('background');
    element.style.removeProperty('outline');
    log('‚úÖ Element un-excluded:', element.tagName, element.className);
  } else {
    // Check if this element would create a too-generic selector
    const tempSelector = generateSelector(element);
    const isBareTag = /^[a-z]+$/i.test(tempSelector.trim());
    
    if (isBareTag) {
      // Show warning tooltip near element
      const warning = document.createElement('div');
      warning.style.cssText = `
        position: absolute;
        background: #f56565;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 999998;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: none;
      `;
      warning.textContent = `‚ö†Ô∏è Too generic - will be skipped!`;
      
      const rect = element.getBoundingClientRect();
      warning.style.left = `${rect.left + window.scrollX}px`;
      warning.style.top = `${rect.top + window.scrollY - 40}px`;
      
      document.body.appendChild(warning);
      setTimeout(() => warning.remove(), 3000);
      
      log('üö® BLOCKED exclusion of ultra-generic element:', tempSelector);
    }
    
    // ‚ö†Ô∏è CHECK IF EXCLUDING HEADING (may affect refresh)
    const isHeading = /^H[1-6]$/i.test(element.tagName);
    const hasHeadingClass = element.className && (
      element.className.includes('heading') ||
      element.className.includes('title') ||
      element.className.includes('header')
    );
    const hasHeadingAttribute = element.hasAttribute('data-testid') && (
      element.getAttribute('data-testid')?.includes('heading') ||
      element.getAttribute('data-testid')?.includes('title')
    );
    
    if (isHeading || hasHeadingClass || hasHeadingAttribute) {
      // Show warning tooltip near element
      const warning = document.createElement('div');
      warning.style.cssText = `
        position: absolute;
        background: #f59e0b;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 999998;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: none;
        max-width: 280px;
        line-height: 1.4;
      `;
      warning.innerHTML = `‚ö†Ô∏è Excluding heading may affect refresh.<br>Keep section labels for best results.`;
      
      const rect = element.getBoundingClientRect();
      warning.style.left = `${rect.left + window.scrollX}px`;
      warning.style.top = `${rect.top + window.scrollY - 60}px`;
      
      document.body.appendChild(warning);
      setTimeout(() => warning.remove(), 4000);
      
      log('‚ö†Ô∏è WARNING: Excluding heading element - may affect refresh');
    }
    
    // Add to excluded list and mark with red
    excludedElements.push(element);
    element.style.setProperty('background', 'rgba(255, 0, 0, 0.3)', 'important');
    element.style.setProperty('outline', '2px solid #ff0000', 'important');
    log('‚ùå Element excluded:', element.tagName, element.className);
  }
  
  }

function handleClick(event: MouseEvent) {
  if (!isCapturing) return;
  
  log('üñ±Ô∏è Click detected on:', event.target);
    
  const target = event.target as HTMLElement;
  
  // If clicking on modal buttons, let them handle it (don't intercept)
  if (target.closest('#spotboard-capture-confirmation')) {
        return;
  }
  
  // If we already have a locked element, check if clicking child for exclusion
  if (lockedElement) {
        
    // Check if clicked element is a child of locked element (but not the locked element itself)
    if (lockedElement.contains(target) && target !== lockedElement) {
            event.preventDefault();
      event.stopPropagation();
      toggleExclusion(target);
      return;
    }
    
        return;
  }
  
  event.preventDefault();
  event.stopPropagation();
  
  log('üéØ Target element:', target.tagName, target.className);
  
  // Lock this element and set green outline
  lockedElement = target;
    target.style.setProperty('outline', '5px solid #00ff00', 'important');
  
  // Generate smart label using Option 1 strategy
  let name = '';
  
  // Strategy 1: Check if element itself is a heading
  if (/^H[1-6]$/i.test(target.tagName)) {
    const text = target.textContent?.trim();
    if (text) {
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from heading:', name);
    }
  }
  
  // Strategy 2: Look for first heading inside element
  if (!name) {
    const heading = target.querySelector('h1, h2, h3, h4, h5, h6');
    if (heading?.textContent?.trim()) {
      const text = heading.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from child heading:', name);
    }
  }
  
  // Strategy 3: Get first meaningful text (skip empty/whitespace-only nodes)
  if (!name) {
    const walker = document.createTreeWalker(
      target,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          const text = node.textContent?.trim();
          return text && text.length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      }
    );
    
    const firstTextNode = walker.nextNode();
    if (firstTextNode?.textContent?.trim()) {
      const text = firstTextNode.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from first text:', name);
    }
  }
  
  // Strategy 4: Fallback to generic label
  if (!name) {
    name = `Spot from ${window.location.hostname}`;
    log('üìù Name fallback:', name);
  }
  
  log('üè∑Ô∏è Final name:', name);
  
  const selector = generateSelector(target);
  log('üéØ Final selector:', selector);
  
  // Show top-right confirmation modal
  showCaptureConfirmation(target, name, selector);
}

function showCaptureConfirmation(target: HTMLElement, name: string, selector: string) {
  // Create top-right confirmation modal
  const modal = document.createElement('div');
  modal.id = 'spotboard-capture-confirmation';
  modal.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #6b46c1;
    color: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 999999;
    min-width: 300px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  `;
  
  modal.innerHTML = `
    <div style="margin-bottom: 16px;">
      <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">
        ‚úÖ Captured: ${name}
      </div>
      <div style="font-size: 14px; opacity: 0.9;">
        Click elements inside the green box to exclude them.<br>
        They'll turn red. Click again to undo.
      </div>
    </div>
    <div style="display: flex; gap: 8px;">
      <button id="confirmSpot" style="flex: 1; padding: 12px; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
        Confirm Spot
      </button>
      <button id="cancelSpot" style="flex: 1; padding: 12px; background: #f56565; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
        Cancel
      </button>
    </div>
  `;
  
  document.body.appendChild(modal);
  
    
  // Confirm button handler - use capture phase to ensure it fires first
  const confirmBtn = modal.querySelector('#confirmSpot') as HTMLButtonElement;
  if (confirmBtn) {
    confirmBtn.addEventListener('click', (e) => {
            e.stopPropagation();
      e.preventDefault();
      modal.remove();
      
      // ‚è≥ WAIT 2 SECONDS FOR JS FRAMEWORKS TO RENDER
      log('‚è≥ Waiting 2s for JavaScript to render...');
      
      setTimeout(() => {
        // üéØ BATCH 1: Generate selectors for excluded elements
        const excludedSelectors: string[] = [];
        excludedElements.forEach(el => {
          const selector = generateSelector(el);
          excludedSelectors.push(selector);
        });
        console.log('üéØ Generated', excludedSelectors.length, 'exclusion selectors');
        
        // ‚ú® SANITIZE HTML BEFORE STORING (after JS renders)
        // Pass excluded elements so they can be removed from saved HTML
        const cleanedHTML = sanitizeHTML(target, excludedElements);
        log('üßπ HTML sanitized, length:', cleanedHTML.length, 'chars');
        
        // üéØ BATCH 2: Extract first heading for self-healing fallback
        // üîß FIX: Extract from LIVE DOM (target), not sanitized HTML
        // Amazon and other sites inject text via JS that cloneNode doesn't capture
        // Live DOM has the rendered text, sanitized clone may have empty spans
        const heading = target.querySelector(`
          h1, h2, h3, h4,
          [class*="heading"], [class*="title"], [class*="header"],
          [data-testid*="heading"], [data-testid*="title"]
        `);
        // Limit to 100 chars to avoid exceeding sync storage quota (8KB per item)
        const rawHeading = heading?.textContent?.trim() || null;
        const headingFingerprint = rawHeading ? rawHeading.substring(0, 100) : null;
        // Always log for debugging - even if null
        log('üîñ Extracted heading fingerprint:', headingFingerprint || 'NULL (no h1-h4 found)');
        
        // Extract domain for favicon
        const domain = new URL(window.location.href).hostname;
        const faviconUrl = `https://www.google.com/s2/favicons?sz=64&domain=${domain}`;
        
        const component = {
          id: crypto.randomUUID(),
          url: window.location.href,
          selector: selector,
          name: name,
          html_cache: cleanedHTML,
          last_refresh: new Date().toISOString(),
          favicon: faviconUrl
        };
        
        log('üì¶ Component object created:', component.id);

        // Save with hybrid storage model
        log('üíæ Attempting hybrid save (sync + local)...');
        
        // Prepare metadata for sync storage (includes selector for cross-device refresh)
        const metadata = {
          id: component.id,
          url: component.url,
          name: component.name,
          favicon: component.favicon,
          customLabel: undefined,  // New captures don't have custom labels yet
          selector: component.selector,
          headingFingerprint: headingFingerprint  // üéØ BATCH 2: Auto-extracted for self-healing
          // üéØ FIX: excludedSelectors stored in LOCAL only (too large for sync quota)
        };
        console.log('üíæ Storing metadata in sync storage (~300 bytes), exclusions in local storage');
        
        // NEW: Save with per-component key instead of array
        const syncKey = `comp-${component.id}`;
        const syncData = {
          [syncKey]: {
            id: component.id,
            name: metadata.name,
            url: metadata.url,
            favicon: metadata.favicon,
            customLabel: metadata.customLabel,
            selector: metadata.selector,
            headingFingerprint: metadata.headingFingerprint,
            excludedSelectors: excludedSelectors, // IMPORTANT: Sync for cross-device!
            last_refresh: component.last_refresh
          }
        };
        
        log('üíæ Saving component with key:', syncKey);
        
        // Save metadata to sync storage with per-component key
        chrome.storage.sync.set(syncData, () => {
            if (chrome.runtime.lastError) {
              console.error('‚ùå Sync storage set error:', chrome.runtime.lastError);
              showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
              return;
            }
            
            log('‚úÖ Metadata saved to sync storage');
            
            // Save full component data to local storage (including selector)
            chrome.storage.local.get(['componentsData'], (localResult) => {
              const localData: Record<string, any> = localResult.componentsData || {};
              localData[component.id] = {
                selector: component.selector,
                html_cache: component.html_cache,
                last_refresh: component.last_refresh,
                excludedSelectors: excludedSelectors  // BATCH 2: Store exclusion selectors
              };
              
              chrome.storage.local.set({ componentsData: localData }, () => {
                if (chrome.runtime.lastError) {
                  console.error('‚ùå Local storage set error:', chrome.runtime.lastError);
                  showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
                  return;
                }
                
                log('‚úÖ Full data saved to local storage');
                log('‚úÖ Component saved successfully (hybrid)!');
                
                // Clear green flash and unlock
                target.style.outline = '';
                target.style.cursor = '';
                lockedElement = null;
                resetExclusions();
                                
                showStyledNotification(`‚úÖ Saved: ${name}`, 'success');
                toggleCapture(false);
              });
            });
          });
      }, 2000);
    }, true); // Use capture phase
  }
  
  // Cancel button handler - use capture phase
  const cancelBtn = modal.querySelector('#cancelSpot') as HTMLButtonElement;
  if (cancelBtn) {
    cancelBtn.addEventListener('click', (e) => {
            e.stopPropagation();
      e.preventDefault();
      modal.remove();
      // Clear green flash and unlock
      target.style.outline = '';
      target.style.cursor = '';
      lockedElement = null;
      resetExclusions();
            toggleCapture(false);
    }, true); // Use capture phase
  }
  
  // Handle Escape key to close modal
  const escapeHandler = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
            modal.remove();
      target.style.outline = '';
      target.style.cursor = '';
      lockedElement = null;
      resetExclusions();
            document.removeEventListener('keydown', escapeHandler);
    }
  };
  document.addEventListener('keydown', escapeHandler);
}

// 4. Escape Key Handler
function handleKeydown(event: KeyboardEvent) {
  if (event.key === "Escape" && isCapturing) {
    toggleCapture(false);
    alert("‚ùå Capture Cancelled");
  }
}

// Main Toggle Logic
function toggleCapture(forceState?: boolean) {
  isCapturing = forceState !== undefined ? forceState : !isCapturing;
  
  if (isCapturing) {
    log("üü¢ Capture Mode: ON");
    document.addEventListener('mouseover', handleHover, true);
    document.addEventListener('mouseout', handleExit, true);
    document.addEventListener('click', handleClick, true);
    document.addEventListener('keydown', handleKeydown, true);
  } else {
    log("üî¥ Capture Mode: OFF");
    document.removeEventListener('mouseover', handleHover, true);
    document.removeEventListener('mouseout', handleExit, true);
    document.removeEventListener('click', handleClick, true);
    document.removeEventListener('keydown', handleKeydown, true);
    
    // Force cleanup all visuals
    document.querySelectorAll('*').forEach(el => {
      (el as HTMLElement).style.outline = '';
      (el as HTMLElement).style.cursor = '';
    });
  }
}

// Message Listener
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.message === "TOGGLE_CAPTURE" || request.type === "TOGGLE_CAPTURE") {
    toggleCapture();
  }
});