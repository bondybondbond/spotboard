console.log("üöÄ SpotBoard: Content Script Loaded");
import { cleanupDuplicates } from './utils/dom-cleanup';

// Debug mode - set to true for detailed logging
const DEBUG = false;
const log = (...args: any[]) => DEBUG && console.log(...args);

let isCapturing = false;
let lockedElement: HTMLElement | null = null; // Track element waiting for confirmation
let excludedElements: HTMLElement[] = []; // Track child elements marked for exclusion (red)
let previewDebounceTimer: ReturnType<typeof setTimeout> | null = null;

// Onboarding playground detection
const SANDBOX_URL_PATTERN = 'bondybondbond.github.io/spotboard/sandbox.html';
const isPlaygroundPage = window.location.href.includes(SANDBOX_URL_PATTERN);

// Inject onboarding beacon on playground page (observed by sandbox.html MutationObserver)
if (isPlaygroundPage) {
  const beacon = document.createElement('div');
  beacon.id = 'sb-onboarding-beacon';
  beacon.dataset.stage = 'ready';
  beacon.dataset.version = '1';
  beacon.dataset.dashboardUrl = chrome.runtime.getURL('dashboard.html') + '?from=playground';
  beacon.style.display = 'none';
  // Append to body (not documentElement) so sandbox.html's body MutationObserver can detect it
  (document.body || document.documentElement).appendChild(beacon);
  log('üéØ Playground beacon injected: data-stage=ready');

  // Watch for actions from sandbox page (e.g. "open-dashboard")
  // Sandbox page can't call chrome.runtime.sendMessage (web context), so it sets
  // data-action on the beacon and we relay it from the extension context.
  new MutationObserver((mutations) => {
    for (const m of mutations) {
      if (m.attributeName === 'data-action' && beacon.dataset.action === 'open-dashboard') {
        beacon.dataset.action = ''; // consume
        chrome.runtime.sendMessage({ action: 'focusDashboard' }, (response) => {
          if (!response || !response.found) {
            chrome.runtime.sendMessage({ action: 'openDashboard' });
          }
        });
      }
    }
  }).observe(beacon, { attributes: true, attributeFilter: ['data-action'] });
}


// Check if an ID looks auto-generated and should be avoided
function isAutoGeneratedId(id: string): boolean {
  if (!id) return false;
  
  // Patterns for auto-generated IDs:
  // - Starts with "yui_" (Yahoo UI framework)
  // - Contains long sequences of numbers (10+ digits, likely timestamps)
  // - Contains UUID patterns (hex-hex-hex-hex-hex)
  // - React/Vue generated IDs
  const patterns = [
    /^yui_/i,                    // Yahoo UI: yui_3_18_1_1_1764458743229_1180
    /\d{10,}/,                   // Long numbers (timestamps): id_1234567890123
    /[a-f0-9]{8}-[a-f0-9]{4}/i,  // UUID-like: 12345678-1234-...
    /^react-/i,                  // React: react-select-2-option-1
    /^__BVID__/i,                // Vue Bootstrap
    /^ember\d+/i                 // Ember: ember123
  ];
  
  return patterns.some(pattern => pattern.test(id));
}

// Generate a specific CSS selector for an element
function generateSelector(element: HTMLElement): string {
  log('üéØ Starting selector generation for:', element.tagName, element.className);
  
  // Priority 1: ID (only if NOT auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    log('‚úÖ Found stable ID selector:', `#${element.id}`);
    return `#${element.id}`;
  } else if (element.id && isAutoGeneratedId(element.id)) {
    log('‚ö†Ô∏è Skipping auto-generated ID:', element.id);
  }
  
  // Build base selector: tag + classes + data attributes
  let baseSelector = buildBaseSelector(element);
  log('üìã Base selector:', baseSelector);
  
  // Check if selector is unique on the page
  const matches = document.querySelectorAll(baseSelector);
  log(`üîç Base selector matches ${matches.length} elements`);
  
  if (matches.length === 1) {
    log('üéØ Generated unique selector:', baseSelector);
    return baseSelector;
  }
  
  log(`‚ö†Ô∏è Selector "${baseSelector}" matches ${matches.length} elements, adding context...`);
  
  // üÜï TABLE CELL DETECTION: Prepend column selector to make it unique
  const cellElement = element.closest('td, th') as HTMLTableCellElement | null;
  if (cellElement) {
    const columnIndex = cellElement.cellIndex; // 0-based
    if (columnIndex !== undefined && columnIndex >= 0) {
      const cellTag = cellElement.tagName.toLowerCase();
      // Check if element is direct child of cell or nested
      const isDirectChild = element.parentElement === cellElement;
      const combinator = isDirectChild ? ' > ' : ' ';
      const columnSelector = `${cellTag}:nth-child(${columnIndex + 1})${combinator}${baseSelector}`;
      
      const columnMatches = document.querySelectorAll(columnSelector);
      log(`üîç Table column selector matches ${columnMatches.length} elements`);
      
      if (columnMatches.length <= matches.length) {
        log('üéØ Generated unique selector with column context:', columnSelector);
        return columnSelector;
      }
    }
  }
  
  // For very generic selectors, go straight to path-based approach
  if (baseSelector === element.tagName.toLowerCase() && matches.length > 50) {
    log('üî§ Element is too generic, skipping to path-based selector...');
  }
  
  // Not unique - try adding nth-of-type
  const parent = element.parentElement;
  if (parent) {
    const siblings = Array.from(parent.children).filter(
      child => child.matches(baseSelector.split('[')[0]) // Match by tag.class without attrs
    );
    const index = siblings.indexOf(element) + 1;
    
    if (index > 0) {
      const nthSelector = `${baseSelector}:nth-of-type(${index})`;
      const nthMatches = document.querySelectorAll(nthSelector);
      log(`üîç nth-of-type selector matches ${nthMatches.length} elements`);
      
      if (nthMatches.length === 1) {
        log('üéØ Generated unique selector with nth-of-type:', nthSelector);
        return nthSelector;
      }
    }
  }
  
  // Still not unique - build path from unique ancestor
  const pathSelector = buildPathFromUniqueAncestor(element, baseSelector);
  if (pathSelector) {
    log('üéØ Generated unique selector with ancestor path:', pathSelector);
    return pathSelector;
  }
  
  // üö® CRITICAL: Never return ultra-generic selectors (bare tag names)
  // These will match TOO MANY elements during refresh and cause content removal
  const isBareTag = /^[a-z]+$/i.test(baseSelector); // Just a tag name like "div", "span", "a"
  
  if (isBareTag) {
    log('üö® BLOCKING ultra-generic selector:', baseSelector);
    // Force path-based approach by adding parent context
    const parent = element.parentElement;
    if (parent) {
      const parentBase = buildBaseSelector(parent);
      const contextSelector = `${parentBase} > ${baseSelector}`;
      log('‚úÖ Adding parent context:', contextSelector);
      return contextSelector;
    }
  }
  
  // Last resort: return base selector (fingerprint will catch mismatches)
  log('‚ö†Ô∏è Could not make selector unique, using:', baseSelector);
  return baseSelector;
}

// Helper: Escape special characters in CSS class names (for Tailwind etc.)
function escapeCSSClass(className: string): string {
  // Escape special characters that are invalid in CSS selectors
  // Common in Tailwind: : / [ ] ( ) @ ! # $ % ^ & * + = , . < > ? ~ 
  return className
    .replace(/:/g, '\\:')   // xl:mt-0 -> xl\:mt-0
    .replace(/\//g, '\\/')  // w-3/12 -> w-3\/12
    .replace(/\[/g, '\\[')  // [&_svg] -> \[&_svg\]
    .replace(/\]/g, '\\]')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)')
    .replace(/\./g, '\\.')  // Important: escape dots in class names
    .replace(/#/g, '\\#')
    .replace(/!/g, '\\!')
    .replace(/@/g, '\\@')
    .replace(/\$/g, '\\$')
    .replace(/%/g, '\\%')
    .replace(/\^/g, '\\^')
    .replace(/&/g, '\\&')
    .replace(/\*/g, '\\*')
    .replace(/\+/g, '\\+')
    .replace(/=/g, '\\=')
    .replace(/,/g, '\\,')
    .replace(/</g, '\\<')
    .replace(/>/g, '\\>')
    .replace(/\?/g, '\\?')
    .replace(/~/g, '\\~');
}

// Helper: Build base selector (tag + classes + data attrs)
function buildBaseSelector(element: HTMLElement): string {
  let selector = element.tagName.toLowerCase();
  
  // Add classes (max 3 to avoid overly specific selectors)
  if (element.classList.length > 0) {
    const classes = Array.from(element.classList)
      .filter(c => !c.includes('hover') && !c.includes('active')) // Skip state classes
      .slice(0, 3)
      .map(c => escapeCSSClass(c)); // ‚ú® ESCAPE SPECIAL CHARACTERS
    if (classes.length > 0) {
      selector += '.' + classes.join('.');
    }
  }
  
  // Add key data attributes (very useful for modern sites like BBC)
  const usefulAttrs = ['data-testid', 'data-test', 'data-component', 'data-section', 'data-module', 'data-type', 'data-t', 'role'];
  for (const attr of usefulAttrs) {
    if (element.hasAttribute(attr)) {
      const value = element.getAttribute(attr);
      selector += `[${attr}="${value}"]`;
      break; // One data attr is usually enough
    }
  }
  
  return selector;
}

// Helper: Walk up DOM to find unique ancestor, build path
function buildPathFromUniqueAncestor(element: HTMLElement, baseSelector: string): string | null {
  let current = element.parentElement;
  const pathParts: string[] = [baseSelector];
  
  while (current && current.tagName !== 'BODY' && current.tagName !== 'HTML') {
    // Check if this ancestor has an ID
    if (current.id) {
      pathParts.unshift(`#${current.id}`);
      const fullPath = pathParts.join(' > ');
      if (document.querySelectorAll(fullPath).length === 1) {
        return fullPath;
      }
    }
    
    // Check for unique data attributes on ancestor
    const usefulAttrs = ['data-testid', 'data-component', 'data-section', 'data-module', 'data-type'];
    for (const attr of usefulAttrs) {
      if (current.hasAttribute(attr)) {
        const ancestorSelector = `${current.tagName.toLowerCase()}[${attr}="${current.getAttribute(attr)}"]`;
        pathParts.unshift(ancestorSelector);
        const fullPath = pathParts.join(' > ');
        if (document.querySelectorAll(fullPath).length === 1) {
          return fullPath;
        }
        pathParts.shift(); // Remove if not unique
      }
    }
    
    // Add parent to path and continue up
    const parentSelector = buildBaseSelector(current);
    pathParts.unshift(parentSelector);
    
    // Check if path is now unique
    const fullPath = pathParts.join(' > ');
    if (document.querySelectorAll(fullPath).length === 1) {
      return fullPath;
    }
    
    // Limit depth to avoid overly long selectors
    if (pathParts.length > 4) {
      break;
    }
    
    current = current.parentElement;
  }
  
  return null;
}

// 1. Hover Handler (The Red Box)
function handleHover(event: MouseEvent) {
  if (!isCapturing) return;
  
  const target = event.target as HTMLElement;
  
  // Ignore SpotBoard banner - never highlight it
  if (target.closest('[data-spotboard-ignore]')) {
    return;
  }

  // Ignore playground onboarding UI elements
  if (target.closest('[data-sb-no-capture]')) {
    return;
  }

  // FIRST: Don't touch modal at all - this must come before ANY other logic
  if (target.closest('#spotboard-capture-confirmation')) {
    return;
  }
  
    
  if (lockedElement) {
        
    // Keep green outline on locked element
    lockedElement.style.setProperty('outline', '5px solid #00ff00', 'important');
    
    // Check if hovering over a child of locked element (but not the locked element itself)
    if (lockedElement.contains(target) && target !== lockedElement) {
      // Check if this element is already excluded
      const isAlreadyExcluded = excludedElements.includes(target);
      
      if (isAlreadyExcluded) {
        // Keep the solid red styling for already-excluded elements
        target.style.setProperty('background', 'rgba(255, 0, 0, 0.3)', 'important');
        target.style.setProperty('outline', '2px solid #ff0000', 'important');
      } else {
        // Show dashed red border preview for potential exclusion
        target.style.setProperty('outline', '2px dashed #ff0000', 'important');
        target.style.setProperty('background', 'transparent', 'important');
      }
      target.style.cursor = 'pointer';
    }
    
    return;
  }
  
  // Normal capture mode: show red outline for element selection
  target.style.setProperty('outline', '5px solid red', 'important');
  target.style.cursor = 'crosshair';
  
  event.stopPropagation();
}

// 2. Exit Handler (Cleanup)
function handleExit(event: MouseEvent) {
  if (!isCapturing) return;
  const target = event.target as HTMLElement;
  
  // Ignore SpotBoard banner
  if (target.closest('[data-spotboard-ignore]')) {
    return;
  }
  
  // FIRST: Don't touch modal at all
  if (target.closest('#spotboard-capture-confirmation')) {
    return;
  }
  
  // If in exclusion mode (element locked)
  if (lockedElement) {
    // Don't clear styling from locked element or already-excluded elements
    if (target === lockedElement || excludedElements.includes(target)) {
      return;
    }
    // Clear preview styling from non-excluded children
    target.style.removeProperty('outline');
    target.style.removeProperty('background');
    return;
  }
  
  // Normal mode: clear hover styling
  target.style.outline = '';
}

// 3. Click Handler (The Save)
// Sanitize captured HTML - remove capture artifacts
// Show styled notification modal instead of alert
function showStyledNotification(message: string, type: 'success' | 'error' = 'success') {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    background: rgba(0, 0, 0, 0.5) !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    z-index: 2147483647 !important;
    isolation: isolate !important;
  `;
  
  const modalContent = document.createElement('div');
  const bgColor = type === 'success' ? '#2d3748' : '#742a2a';
  modalContent.style.cssText = `
    background: ${bgColor} !important;
    color: white !important;
    padding: 24px !important;
    border-radius: 8px !important;
    max-width: 400px !important;
    width: 90% !important;
    text-align: center !important;
    position: relative !important;
    z-index: 2147483647 !important;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
  `;

  // üéØ BATCH 1.5: Enhanced notification with "View on SpotBoard" button
  modalContent.innerHTML = `
    <div style="font-size: 16px; margin-bottom: 20px; line-height: 1.5; font-family: inherit;">
      ${message}
    </div>
    <div style="display: flex; gap: 12px; flex-direction: column; font-family: inherit;">
      <button id="viewBoardBtn" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; font-family: inherit;">
        View on SpotBoard
      </button>
      <button id="closeNotification" style="width: 100%; padding: 12px; background: #4299e1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; font-family: inherit;">
        Close
      </button>
    </div>
  `;
  
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // View Board button - smart navigation
  const viewBtn = modal.querySelector('#viewBoardBtn');
  if (viewBtn) {
    viewBtn.addEventListener('click', () => {
      const dashboardUrl = chrome.runtime.getURL('dashboard.html');
      
      // Check if dashboard already open
      chrome.runtime.sendMessage({ action: 'focusDashboard' }, (response) => {
        if (!response || !response.found) {
          // Dashboard not open, create new tab
          chrome.runtime.sendMessage({ action: 'openDashboard' });
        }
        // If found, background script already focused it
      });
      
      modal.remove();
    });
  }
  
  // Close button
  const closeBtn = modal.querySelector('#closeNotification');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.remove());
  }
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// Sentiment Detection for Finance Data (Phase 2: Semantic Coloring)
// Detects positive/negative deltas (e.g., "+2.45%", "-1.50%") and tags elements
// for color coding on the dashboard
function tagSentimentData(element: HTMLElement): void {
  // Find all text nodes and their parent elements
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    null
  );

  const textNodesToTag: Array<{ node: Text; sentiment: 'positive' | 'negative' | 'neutral' }> = [];

  let node: Node | null;
  while ((node = walker.nextNode())) {
    const text = node.textContent?.trim() || '';
    if (text.length === 0) continue;

    // Regex patterns for sentiment detection
    // Positive: starts with + or contains +X.XX% (but not ¬±)
    // Negative: starts with - or contains -X.XX% (but not just a dash in text)
    const positivePattern = /^\+|(?<!\¬±)\+\d+\.?\d*%?/;
    const negativePattern = /^-\d|(?<!\¬±)-\d+\.?\d*%?/;

    let sentiment: 'positive' | 'negative' | 'neutral' | null = null;

    if (positivePattern.test(text)) {
      sentiment = 'positive';
    } else if (negativePattern.test(text)) {
      sentiment = 'negative';
    }

    if (sentiment) {
      textNodesToTag.push({ node: node as Text, sentiment });
    }
  }

  // Tag the parent elements (usually the clickable element)
  let tagged = 0;
  textNodesToTag.forEach(({ node, sentiment }) => {
    let parent = node.parentElement;

    // Find the clickable ancestor (a, button) or closest block element
    while (parent && parent !== element) {
      if (parent.tagName === 'A' || parent.tagName === 'BUTTON' || parent.tagName === 'SPAN') {
        parent.setAttribute('data-sb-sentiment', sentiment);
        tagged++;
        break;
      }
      parent = parent.parentElement;
    }

    // Fallback: tag immediate parent if no clickable ancestor found
    if (node.parentElement && !node.parentElement.hasAttribute('data-sb-sentiment')) {
      node.parentElement.setAttribute('data-sb-sentiment', sentiment);
      tagged++;
    }
  });

  if (tagged > 0) {
    console.log(`‚úÖ Tagged ${tagged} element(s) with sentiment data`);
  }
}

function sanitizeHTML(element: HTMLElement, excludedElements: HTMLElement[] = []): string {
  console.log('üßπ sanitizeHTML called with', excludedElements.length, 'excluded elements');
  
  // üéØ STEP 1: Mark hidden elements in ORIGINAL DOM (before cloning)
  // Check computed styles on live DOM elements, then mark them for removal
  const allOriginalElements = [element, ...Array.from(element.querySelectorAll('*'))];
  const markedElements: HTMLElement[] = [];
  
  // Get the captured element's bounding rect for relative position checking
  const containerRect = element.getBoundingClientRect();
  
  // Helper: Find nearest ancestor that clips content (carousel container)
  const findClippingAncestor = (el: HTMLElement): DOMRect => {
    let parent = el.parentElement;
    while (parent && parent !== element) {
      const style = window.getComputedStyle(parent);
      // Check all overflow values that cause clipping
      const overflowX = style.overflowX;
      const overflow = style.overflow;
      const isClipping = 
        overflow === 'hidden' || overflow === 'scroll' || overflow === 'auto' || overflow === 'clip' ||
        overflowX === 'hidden' || overflowX === 'scroll' || overflowX === 'auto' || overflowX === 'clip';
      
      if (isClipping) {
        const parentRect = parent.getBoundingClientRect();
        // Only use this container if it's narrower than our current reference (actual clipping)
        // and reasonably sized (not a tiny element)
        if (parentRect.width < containerRect.width && parentRect.width > 50) {
          return parentRect;
        }
      }
      parent = parent.parentElement;
    }
    return containerRect; // Fallback to outer container
  };
  
  
  allOriginalElements.forEach(el => {
    if (el instanceof HTMLElement && el !== element) {
      const computed = window.getComputedStyle(el);
      
      // üéØ COMPREHENSIVE VISIBILITY CHECK
      // Method 1: CSS-based hiding
      const isDisplayNone = computed.display === 'none';
      const isVisibilityHidden = computed.visibility === 'hidden';
      const isOpacityZero = computed.opacity === '0';
      const isAriaHidden = el.getAttribute('aria-hidden') === 'true';
      
      // Method 2: Off-screen positioning (carousel slides)
      // Use the nearest clipping ancestor (overflow:hidden) for bounds check
      const rect = el.getBoundingClientRect();
      const clipRect = findClippingAncestor(el);
      const isOffScreenLeft = rect.right < clipRect.left;   // Fully left of clip container
      const isOffScreenRight = rect.left > clipRect.right;  // Fully right of clip container
      const isOffScreen = isOffScreenLeft || isOffScreenRight;
      
      const isHidden = isDisplayNone || isVisibilityHidden || isOpacityZero || isAriaHidden || isOffScreen;
      
      if (isHidden) {
        el.setAttribute('data-spotboard-hidden', 'true');
        markedElements.push(el);
      }
    }
  });

  // üéØ IMAGE CONTEXT CLASSIFICATION (BEFORE CLONING)
  // 5-tier system based on rendered size and container ratio:
  // Icon (25px): Tiny images like logos, avatars, voting buttons
  // Small (48px): Avatars, badges
  // Thumbnail (80px): HotUK style deal images
  // Medium (100px): Zoopla property images (landscape)
  // Preview (150px): Large product hero images
  element.querySelectorAll('img').forEach(img => {
    try {
      // Get nearest structural container (article, section, or direct parent)
      let container = img.closest('article, section') || img.parentElement;
      if (!container) {
        console.log('  ‚ö†Ô∏è Image has no container, defaulting to icon');
        img.setAttribute('data-scale-context', 'icon');
        return;
      }
      
      // Calculate container dimensions (works because element is in DOM)
      const containerRect = container.getBoundingClientRect();
      const containerArea = containerRect.width * containerRect.height;
      
      // Calculate RENDERED image dimensions
      const imgRect = img.getBoundingClientRect();
      const imageArea = imgRect.width * imgRect.height;
      const imgHeight = imgRect.height;
      
      // Calculate area ratio
      const areaRatio = containerArea > 0 ? imageArea / containerArea : 0;
      
      // üêõ DEBUG: Log image dimensions for AS.com investigation
      const imgSrc = img.src.substring(img.src.lastIndexOf('/') + 1, img.src.lastIndexOf('/') + 30);
      console.log(`  üì∏ IMG DEBUG: ${imgSrc}`, {
        rendered: `${Math.round(imgRect.width)}x${Math.round(imgRect.height)}`,
        container: `${Math.round(containerRect.width)}x${Math.round(containerRect.height)}`,
        areaRatio: `${(areaRatio * 100).toFixed(1)}%`,
        imageArea,
        widthAttr: img.getAttribute('width'),
        heightAttr: img.getAttribute('height'),
        className: img.className.substring(0, 40)
      });
      
      // 5-tier classification logic (HEIGHT-BASED primary)
      let context: 'icon' | 'small' | 'thumbnail' | 'medium' | 'preview';
      
      // Rule 1: Tiny images (<40px height) = icon (25px)
      if (imgHeight < 40 || imageArea < 1600) {
        context = 'icon';
      }
      // Rule 2: Small images (<70px height) = small (48px)
      else if (imgHeight < 70 || imageArea < 4900) {
        context = 'small';
      }
      // Rule 3: Small ratio (<10%) = small (48px) - decorative
      else if (areaRatio < 0.10) {
        context = 'small';
      }
      // Rule 4: Medium ratio (10-25%) = thumbnail (80px)
      else if (areaRatio < 0.25 || imageArea < 15000) {
        context = 'thumbnail';
      }
      // Rule 5: Medium-large ratio (25-50%) = medium (100px)
      else if (areaRatio < 0.50 || imageArea < 40000) {
        context = 'medium';
      }
      // Rule 6: Large ratio (>50%) AND large area = preview (150px)
      else {
        context = 'preview';
      }
      
      img.setAttribute('data-scale-context', context);
      console.log(`  ‚úÖ Classified as: ${context.toUpperCase()}`);
      
    } catch (e) {
      console.warn('  ‚ö†Ô∏è Failed to classify image, defaulting to icon:', e);
      img.setAttribute('data-scale-context', 'icon');
    }
  });


  // üíö‚ù§Ô∏è SENTIMENT TAGGING (Phase 2: Semantic Coloring)
  // Tag finance deltas (+/-) for color coding on dashboard
  tagSentimentData(element);

  // Clone (classification attributes will be copied)
  const clone = element.cloneNode(true) as HTMLElement;
  
  // Clean up markers from original DOM (restore page to pristine state)
  markedElements.forEach(el => el.removeAttribute('data-spotboard-hidden'));
  
  // üéØ REMOVE USER-EXCLUDED ELEMENTS
  // User marked these elements for exclusion before confirming capture
  // We need to find them in the clone using path-based matching
  if (excludedElements.length > 0) {
    console.log('üéØ Processing', excludedElements.length, 'user-excluded elements');
    
    // For each excluded element, calculate its path from root
    // Then find the same element in the clone using that path
    excludedElements.forEach(excludedEl => {
      // Get path from root element to excluded element
      const path = getElementPath(excludedEl, element);
      console.log('  üìç Excluded element path:', path, excludedEl.tagName, excludedEl.className);
      
      // Find corresponding element in clone using path
      const elementInClone = getElementByPath(clone, path);
      
      if (elementInClone) {
        elementInClone.remove();
        console.log('  ‚úÖ Removed excluded element from clone');
      } else {
        console.warn('  ‚ö†Ô∏è Could not find excluded element in clone');
      }
    });
  }
  
  // üéØ Remove elements with display:none (catches CSS-based hidden duplicates)
  // The Verge and other sites use CSS-in-JS classes where mobile/desktop versions
  // are differentiated by computed display style rather than class keywords
  // Strategy: Mark hidden elements in ORIGINAL DOM before cloning, then remove from clone
  const hiddenInClone = clone.querySelectorAll('[data-spotboard-hidden="true"]');
  hiddenInClone.forEach(el => el.remove());

  // Remove capture-related inline styles from clone
  const cloneElements = [clone, ...Array.from(clone.querySelectorAll('*'))];
  cloneElements.forEach(el => {
    if (el instanceof HTMLElement) {
      el.style.removeProperty('cursor');
      el.style.removeProperty('outline');
      if (el.style.length === 0) {
        el.removeAttribute('style');
      }
    }
  });

  // üéØ Apply shared duplicate/hidden element cleanup (from dom-cleanup.ts)
  // Handles: duplicate selectors, empty wrappers, broken SVGs, decorative images,
  // progressive loading artifacts, and dangerous positioning
  clone.innerHTML = cleanupDuplicates(clone.innerHTML);
  
  // üéØ FIX PROGRESSIVE LOADING IMAGES: Remove loading artifacts
  // Sites use progressive loading: blur filters, skeleton loaders, lazy loading
  // These break in dashboard because JavaScript that removes them doesn't run
  clone.querySelectorAll('img').forEach(img => {
    // Remove lazy loading attribute
    img.removeAttribute('loading');
    
    // Remove progressive loading classes that cause blur/skeleton effects
    // SlotCatalog: .blurring (filter: blur(4px))
    // Others: .skeleton, .loading, .placeholder, .lazy
    const loadingClasses = ['blurring', 'skeleton', 'loading', 'placeholder', 'lazy', 'lazy-load'];
    loadingClasses.forEach(cls => {
      if (img.classList.contains(cls)) {
        img.classList.remove(cls);
      }
    });
  });
  
  // üéØ FIX LAZY-LOADED IMAGES: Convert data-image/data-src to src
  // Epic Games, many modern sites use data-image, data-src, data-lazy-src for lazy loading
  // These need to be swapped to src before we capture, otherwise images are blank placeholders
  clone.querySelectorAll('img').forEach(img => {
    // Common lazy-load attribute names (in priority order)
    const lazyAttrs = ['data-image', 'data-src', 'data-lazy-src', 'data-original', 'data-lazy'];
    
    for (const attr of lazyAttrs) {
      const lazyUrl = img.getAttribute(attr);
      if (lazyUrl && lazyUrl.startsWith('http')) {
        // Found a real URL in lazy attribute - use it as src
        img.setAttribute('src', lazyUrl);
        break; // Stop after first match
      }
    }
  });
  
  // üéØ FIX PLACEHOLDER DIMENSIONS: Remove aspect ratio markers
  // Sites like AS.com use width="4" height="3" as 4:3 aspect ratio, not 4x3 pixels
  // These break CSS sizing because max-height:25px doesn't expand 3px images
  clone.querySelectorAll('img').forEach(img => {
    const width = parseInt(img.getAttribute('width') || '0');
    const height = parseInt(img.getAttribute('height') || '0');
    
    // Detect placeholder dimensions (< 10px = aspect ratio markers)
    if ((height > 0 && height < 10) || (width > 0 && width < 10)) {
      img.removeAttribute('width');
      img.removeAttribute('height');
    }
  });

  // üéØ FIX RELATIVE URLS: Convert ALL relative URLs to absolute
  // Prevents resources from being resolved to chrome-extension:// origin
  const pageUrl = window.location.href;
  
  // Fix image src attributes
  clone.querySelectorAll('img[src]').forEach(img => {
    const src = img.getAttribute('src');
    
    // üîß Handle protocol-relative URLs (//upload.wikimedia.org/...)
    if (src && src.startsWith('//')) {
      img.setAttribute('src', 'https:' + src);
      return;
    }
    
    if (src && !src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('blob:')) {
      try {
        const absoluteUrl = new URL(src, pageUrl).href;
        img.setAttribute('src', absoluteUrl);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix img src:', src, e);
      }
    }
  });
  
  // Fix image srcset attributes (for responsive images)
  clone.querySelectorAll('img[srcset]').forEach(img => {
    const srcset = img.getAttribute('srcset');
    if (srcset) {
      try {
        const fixedSrcset = srcset.split(',').map(src => {
          const parts = src.trim().split(/\s+/);
          const url = parts[0];
          
          // üîß Handle protocol-relative URLs (//upload.wikimedia.org/...)
          if (url && url.startsWith('//')) {
            parts[0] = 'https:' + url;
            return parts.join(' ');
          }
          
          if (url && !url.startsWith('http') && !url.startsWith('data:') && !url.startsWith('blob:')) {
            const absoluteUrl = new URL(url, pageUrl).href;
            parts[0] = absoluteUrl;
          }
          return parts.join(' ');
        }).join(', ');
        img.setAttribute('srcset', fixedSrcset);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix img srcset:', e);
      }
    }
  });
  
  // Fix link hrefs (so they stay clickable)
  clone.querySelectorAll('a[href]').forEach(link => {
    const href = link.getAttribute('href');
    if (href && !href.startsWith('#') && !href.startsWith('javascript:') && !href.startsWith('mailto:') && !href.startsWith('tel:') && !href.startsWith('http')) {
      try {
        const absoluteUrl = new URL(href, pageUrl).href;
        link.setAttribute('href', absoluteUrl);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix link href:', href, e);
      }
    }
  });
  
  // Fix CSS background images in inline styles
  clone.querySelectorAll('[style]').forEach(el => {
    const style = (el as HTMLElement).getAttribute('style');
    if (style && style.includes('url(')) {
      try {
        const fixedStyle = style.replace(/url\(['"]?([^'"()]+)['"]?\)/g, (match, url) => {
          if (url.startsWith('data:') || url.startsWith('blob:') || url.startsWith('http')) {
            return match;
          }
          try {
            const absoluteUrl = new URL(url, pageUrl).href;

            return `url('${absoluteUrl}')`;
          } catch (e) {
            return match;
          }
        });
        (el as HTMLElement).setAttribute('style', fixedStyle);
      } catch (e) {
        console.warn('  ‚ö†Ô∏è Could not fix CSS background:', e);
      }
    }
  });
  
  return clone.outerHTML;
}

// Helper: Get path from root to element
function getElementPath(element: Element, root: Element): number[] {
  const path: number[] = [];
  let current = element;
  
  while (current && current !== root) {
    const parent = current.parentElement;
    if (!parent) break;
    
    const index = Array.from(parent.children).indexOf(current);
    path.unshift(index);
    current = parent;
  }
  
  return path;
}

// Helper: Get element from clone using path
function getElementByPath(root: Element, path: number[]): Element | null {
  let current: Element | null = root;
  
  for (const index of path) {
    if (!current) return null;
    current = current.children[index] || null;
  }
  
  return current;
}


// Toggle exclusion marking on child element

// Clear all exclusion markings and reset array
function resetExclusions() {
  // Remove red markings from all excluded elements
  excludedElements.forEach(el => {
    el.style.removeProperty('background');
    el.style.removeProperty('outline');
  });
  // Clear the array
  excludedElements = [];
  log('üßπ All exclusions cleared');
}

function toggleExclusion(element: HTMLElement) {
  const isExcluded = excludedElements.includes(element);
  
  if (isExcluded) {
    // Remove from excluded list and remove red marking
    excludedElements = excludedElements.filter(el => el !== element);
    element.style.removeProperty('background');
    element.style.removeProperty('outline');
    log('‚úÖ Element un-excluded:', element.tagName, element.className);
  } else {
    // Check if this element would create a too-generic selector
    const tempSelector = generateSelector(element);
    const isBareTag = /^[a-z]+$/i.test(tempSelector.trim());
    
    if (isBareTag) {
      // Show warning tooltip near element
      const warning = document.createElement('div');
      warning.style.cssText = `
        position: absolute;
        background: #f56565;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 999998;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: none;
      `;
      warning.textContent = `‚ö†Ô∏è Too generic - will be skipped!`;
      
      const rect = element.getBoundingClientRect();
      warning.style.left = `${rect.left + window.scrollX}px`;
      warning.style.top = `${rect.top + window.scrollY - 40}px`;
      
      document.body.appendChild(warning);
      setTimeout(() => warning.remove(), 3000);
      
      log('üö® BLOCKED exclusion of ultra-generic element:', tempSelector);
    }
    
    // ‚ö†Ô∏è CHECK IF EXCLUDING HEADING (may affect refresh)
    const isHeading = /^H[1-6]$/i.test(element.tagName);
    const hasHeadingClass = element.className && (
      element.className.includes('heading') ||
      element.className.includes('title') ||
      element.className.includes('header')
    );
    const hasHeadingAttribute = element.hasAttribute('data-testid') && (
      element.getAttribute('data-testid')?.includes('heading') ||
      element.getAttribute('data-testid')?.includes('title')
    );
    
    if (isHeading || hasHeadingClass || hasHeadingAttribute) {
      // Show warning tooltip near element
      const warning = document.createElement('div');
      warning.style.cssText = `
        position: absolute;
        background: #f59e0b;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 999998;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        pointer-events: none;
        max-width: 280px;
        line-height: 1.4;
      `;
      warning.innerHTML = `‚ö†Ô∏è Excluding heading may affect refresh.<br>Keep section labels for best results.`;
      
      const rect = element.getBoundingClientRect();
      warning.style.left = `${rect.left + window.scrollX}px`;
      warning.style.top = `${rect.top + window.scrollY - 60}px`;
      
      document.body.appendChild(warning);
      setTimeout(() => warning.remove(), 4000);
      
      log('‚ö†Ô∏è WARNING: Excluding heading element - may affect refresh');
    }
    
    // Add to excluded list and mark with red
    excludedElements.push(element);
    element.style.setProperty('background', 'rgba(255, 0, 0, 0.3)', 'important');
    element.style.setProperty('outline', '2px solid #ff0000', 'important');
    log('‚ùå Element excluded:', element.tagName, element.className);
  }
  
  // Debounced preview refresh on exclusion toggle
  if (previewDebounceTimer) clearTimeout(previewDebounceTimer);
  previewDebounceTimer = setTimeout(() => updatePreview(), 300);
  }

function handleClick(event: MouseEvent) {
  if (!isCapturing) return;
  
  log('üñ±Ô∏è Click detected on:', event.target);
    
  const target = event.target as HTMLElement;
  
  // Ignore clicks on SpotBoard banner (has pointer-events: none, but belt-and-braces)
  if (target.closest('[data-spotboard-ignore]')) {
    return;
  }

  // Ignore playground onboarding UI elements
  if (target.closest('[data-sb-no-capture]')) {
    return;
  }

  // If clicking on modal buttons, let them handle it (don't intercept)
  if (target.closest('#spotboard-capture-confirmation')) {
        return;
  }
  
  // If we already have a locked element, check if clicking child for exclusion
  if (lockedElement) {
        
    // Check if clicked element is a child of locked element (but not the locked element itself)
    if (lockedElement.contains(target) && target !== lockedElement) {
            event.preventDefault();
      event.stopPropagation();
      toggleExclusion(target);
      return;
    }
    
        return;
  }
  
  event.preventDefault();
  event.stopPropagation();
  
  log('üéØ Target element:', target.tagName, target.className);
  
  // Lock this element and set green outline
  lockedElement = target;
  target.style.setProperty('outline', '5px solid #00ff00', 'important');

  // üéØ Playground beacon: element selected (green frame showing, confirmation modal opening)
  if (isPlaygroundPage) {
    const beacon = document.getElementById('sb-onboarding-beacon');
    if (beacon) {
      beacon.dataset.stage = 'selected';
      log('üéØ Playground beacon updated: data-stage=selected');
    }
  }
  
  // Generate smart label using Option 1 strategy
  let name = '';
  
  // Strategy 1: Check if element itself is a heading
  if (/^H[1-6]$/i.test(target.tagName)) {
    const text = target.textContent?.trim();
    if (text) {
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from heading:', name);
    }
  }
  
  // Strategy 2: Look for first heading inside element
  if (!name) {
    const heading = target.querySelector('h1, h2, h3, h4, h5, h6');
    if (heading?.textContent?.trim()) {
      const text = heading.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from child heading:', name);
    }
  }
  
  // Strategy 3: Get first meaningful text (skip empty/whitespace-only nodes)
  if (!name) {
    const walker = document.createTreeWalker(
      target,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          const text = node.textContent?.trim();
          return text && text.length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      }
    );
    
    const firstTextNode = walker.nextNode();
    if (firstTextNode?.textContent?.trim()) {
      const text = firstTextNode.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from first text:', name);
    }
  }
  
  // Strategy 4: Fallback to generic label
  if (!name) {
    name = `Spot from ${window.location.hostname}`;
    log('üìù Name fallback:', name);
  }
  
  log('üè∑Ô∏è Final name:', name);
  
  const selector = generateSelector(target);
  log('üéØ Final selector:', selector);
  
  // üéØ BATCH 2: Pre-extract heading for position-based detection
  // Do this BEFORE modal so we can show auto-selected mode
  const heading = target.querySelector(`
    h1, h2, h3, h4, caption,
    [class*="heading"], [class*="title"], [class*="header"],
    [data-testid*="heading"], [data-testid*="title"]
  `);
  const rawHeading = heading?.textContent?.trim() || null;
  const hasStableHeading = !!rawHeading;
  const positionBased = !hasStableHeading;
  log('üìç Pre-modal capture mode:', positionBased ? 'Position-based (no heading)' : 'Header-based (has heading)');
  
  // Show top-right confirmation modal
  log('üìû About to call showCaptureConfirmation...');
  try {
    showCaptureConfirmation(target, name, selector, positionBased);
    log('‚úÖ showCaptureConfirmation returned');
  } catch (error) {
    console.error('‚ùå showCaptureConfirmation FAILED:', error);
  }
}


/**
 * Returns CSS string that replicates dashboard card rendering.
 * Combines dashboard.html .component-content rules + injectCleanupCSS() rules.
 * This is a static string constant ‚Äî no behavioral logic, just CSS rules.
 */
function getPreviewCSS(): string {
  return `
    /* === Dashboard .component-content rules === */
    body {
      margin: 0;
      padding: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px;
      line-height: 1.25;
      overflow-x: hidden;
      background: #fff;
    }

    * {
      cursor: default !important;
      position: static !important;
    }

    /* 5-tier image scaling */
    img[data-scale-context="icon"] {
      max-width: 25px !important; max-height: 25px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }
    img[data-scale-context="small"] {
      max-width: 48px !important; max-height: 48px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }
    img[data-scale-context="thumbnail"] {
      max-width: 80px !important; max-height: 80px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }
    img[data-scale-context="medium"] {
      max-width: 180px !important; max-height: 100px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }
    img[data-scale-context="preview"] {
      max-width: 150px !important; max-height: 150px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }
    img:not([data-scale-context]) {
      max-width: 25px !important; max-height: 25px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }
    video {
      max-width: 25px !important; max-height: 25px !important;
      object-fit: contain; display: inline-block; vertical-align: middle;
    }

    /* Font normalization */
    body, li, li span, li p, div, p {
      font-size: 14px !important;
      font-weight: 400 !important;
      line-height: 1.25 !important;
    }
    strong, b { font-weight: 600 !important; }
    h1, h2, h3 {
      font-weight: 600 !important;
      font-size: 16px !important;
      line-height: 1.3 !important;
    }
    li { margin: 4px 0 !important; padding: 0 !important; }
    a { cursor: pointer !important; }

    /* üíö‚ù§Ô∏è Sentiment colors for finance data */
    [data-sb-sentiment="positive"] {
      color: #16a34a !important;
      font-weight: 500 !important;
    }
    [data-sb-sentiment="negative"] {
      color: #dc2626 !important;
      font-weight: 500 !important;
    }
    [data-sb-sentiment="positive"] a,
    [data-sb-sentiment="negative"] a {
      color: inherit !important;
      text-decoration: none;
    }
    [data-sb-sentiment="positive"] a:hover,
    [data-sb-sentiment="negative"] a:hover {
      text-decoration: underline;
    }

    /* === injectCleanupCSS() rules === */
    [class*="Pbot"], [class*="Ptop"], [class*="Pvertical"],
    [class*="Mbot"], [class*="Mtop"] {
      padding: 2px !important; margin: 2px 0 !important;
    }
    h6:empty, h5:empty, h4:empty, .sr-only:empty, .visually-hidden:empty {
      display: none !important; margin: 0 !important; padding: 0 !important;
    }
    h6, h5 { margin: 2px 0 !important; padding: 2px 0 !important; }
    ul {
      list-style-type: disc !important; margin: 1px 0 !important; padding-left: 20px !important;
    }
    ol {
      list-style-type: decimal !important; margin: 1px 0 !important; padding-left: 20px !important;
    }
    ul li, ol li {
      line-height: 1.2 !important; margin: 0 !important;
      padding: 1px 0 !important; min-height: 0 !important; height: auto !important;
    }
    li > div, li > section, li > article {
      margin: 0 !important; padding: 2px 0 !important; line-height: 1.2 !important;
    }
    p { margin: 4px 0 !important; line-height: 1.4 !important; }
    div { line-height: 1.4 !important; }
    [class*="Grid"], [class*="Flex"], [class*="Stack"] { gap: 2px !important; }
    table tr { height: auto !important; }
    table td { padding: 4px 6px !important; }
  `;
}

/**
 * Wraps sanitized HTML in a full srcdoc document with dashboard-parity CSS.
 */
function generatePreviewSrcdoc(html: string): string {
  return `<!DOCTYPE html>
<html><head><meta charset="utf-8"><style>${getPreviewCSS()}</style></head>
<body>${html}</body></html>`;
}

/**
 * Renders or re-renders the preview iframe inside the capture confirmation modal.
 * Uses the locked element + current exclusions to generate a dashboard-parity preview.
 */
function updatePreview(): void {
  const iframe = document.querySelector('#spotboard-preview-iframe') as HTMLIFrameElement | null;
  if (!iframe || !lockedElement) return;

  // Save scroll position before replacing content (only possible with allow-same-origin)
  let savedScrollTop = 0;
  try {
    if (iframe.contentDocument?.documentElement) {
      savedScrollTop = iframe.contentDocument.documentElement.scrollTop;
    }
  } catch (_e) {
    // Cross-origin or not yet loaded ‚Äî ignore
  }

  // Generate preview HTML: sanitize the locked element with current exclusions
  const previewHTML = sanitizeHTML(lockedElement, excludedElements);
  // Apply shared cleanup for exact dashboard parity
  const cleanedHTML = cleanupDuplicates(previewHTML);

  iframe.srcdoc = generatePreviewSrcdoc(cleanedHTML);

  // Loading state: fade in when loaded, restore scroll position
  iframe.style.opacity = '0.5';
  iframe.onload = () => {
    iframe.style.opacity = '1';
    // Restore scroll position after content renders
    try {
      if (iframe.contentDocument?.documentElement && savedScrollTop > 0) {
        iframe.contentDocument.documentElement.scrollTop = savedScrollTop;
      }
    } catch (_e) {
      // Cross-origin ‚Äî ignore
    }
  };
}

function showCaptureConfirmation(target: HTMLElement, name: string, selector: string, positionBased: boolean) {
  log('üöÄ showCaptureConfirmation called with:', { name, selector, positionBased });
  
  // Create top-right confirmation modal
  const modal = document.createElement('div');
  modal.id = 'spotboard-capture-confirmation';
  modal.style.cssText = `
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    background: #6b46c1 !important;
    color: white !important;
    padding: 0 !important;
    border-radius: 12px !important;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
    z-index: 2147483647 !important;
    width: 340px !important;
    max-width: 90vw !important;
    max-height: calc(100vh - 40px) !important;
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
    isolation: isolate !important;
  `;
  
  modal.innerHTML = `
    <div style="padding: 20px; flex-shrink: 0; font-family: inherit;">
      <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-family: inherit;" title="${name.replace(/"/g, '&quot;')}">
        ‚úÖ Captured: ${name}
      </div>
      <div style="font-size: 14px; opacity: 0.9; font-family: inherit;">
        Click elements inside the green box to exclude them.<br>
        Preview updates as you exclude.
      </div>
    </div>
    <div style="padding: 0 20px; flex-shrink: 0; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 12px; font-family: inherit;">
      <div id="advancedToggle" style="cursor: pointer; font-size: 13px; opacity: 0.8; user-select: none; font-family: inherit;">
        ‚öôÔ∏è Advanced
      </div>
      <div id="advancedPanel" style="display: none; margin-top: 8px; font-size: 13px; font-family: inherit;">
        <div style="margin-bottom: 6px; opacity: 0.9; font-family: inherit;">Capture mode:</div>
        <label style="display: block !important; margin: 6px 0 !important; cursor: pointer !important; opacity: 0.95 !important; font-family: inherit !important;">
          <input type="radio" name="captureMode" value="header" ${!positionBased ? 'checked' : ''} style="display: inline-block !important; margin-right: 6px !important; width: auto !important; height: auto !important; opacity: 1 !important; position: static !important;">
          <span style="display: inline !important; vertical-align: middle !important; font-family: inherit !important;">Header-based (uses section title)</span>
        </label>
        <label style="display: block !important; margin: 6px 0 !important; cursor: pointer !important; opacity: 0.95 !important; font-family: inherit !important;">
          <input type="radio" name="captureMode" value="position" ${positionBased ? 'checked' : ''} style="display: inline-block !important; margin-right: 6px !important; width: auto !important; height: auto !important; opacity: 1 !important; position: static !important;">
          <span style="display: inline !important; vertical-align: middle !important; font-family: inherit !important;">Position-based (uses spot position on page)</span>
        </label>
      </div>
    </div>
    <div style="padding: 12px 20px; flex: 1; min-height: 0; overflow-y: auto;">
      <div id="spotboard-preview-toggle" style="font-size: 13px; opacity: 0.8; margin-bottom: 6px; cursor: pointer; user-select: none; font-family: inherit;">‚ñæ Preview</div>
      <div id="spotboard-preview-container">
        <iframe id="spotboard-preview-iframe"
          sandbox="allow-same-origin"
          style="width: 100%; height: 250px; border: none; border-radius: 6px; background: #fff; display: block; opacity: 0.5; transition: opacity 0.3s;"
        ></iframe>
      </div>
    </div>
    <div style="display: flex; gap: 8px; padding: 12px 20px; flex-shrink: 0; background: #6b46c1; border-radius: 0 0 12px 12px; position: sticky; bottom: 0; z-index: 1; font-family: inherit;">
      <button id="confirmSpot" style="flex: 1; padding: 12px; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; font-family: inherit;">
        Confirm Spot
      </button>
      <button id="cancelSpot" style="flex: 1; padding: 12px; background: #f56565; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; font-family: inherit;">
        Cancel
      </button>
    </div>
  `;
  
  log('üì¶ Modal HTML created, appending to body...');
  document.body.appendChild(modal);
  log('‚úÖ Modal appended to DOM successfully');
  
  // üéØ Preview collapse toggle
  const previewToggle = modal.querySelector('#spotboard-preview-toggle') as HTMLDivElement;
  const previewContainer = modal.querySelector('#spotboard-preview-container') as HTMLDivElement;
  if (previewToggle && previewContainer) {
    previewToggle.addEventListener('click', () => {
      const isHidden = previewContainer.style.display === 'none';
      previewContainer.style.display = isHidden ? '' : 'none';
      previewToggle.textContent = isHidden ? '‚ñæ Preview' : '‚ñ∏ Preview';
    });
    // Auto-collapse on small viewports (<600px height)
    if (window.innerHeight < 600) {
      previewContainer.style.display = 'none';
      previewToggle.textContent = '‚ñ∏ Preview';
    }
  }

  // Trigger initial preview render
  updatePreview();
  
  // üéØ Remove yellow banner when entering exclusion mode (purple modal)
  const banner = document.getElementById('spotboard-capture-banner');
  if (banner) {
    banner.remove();
    log('üóëÔ∏è Yellow banner removed - now in exclusion mode');
  }
  
  // üéØ BATCH 2: Advanced toggle functionality
  const advancedToggle = modal.querySelector('#advancedToggle') as HTMLDivElement;
  const advancedPanel = modal.querySelector('#advancedPanel') as HTMLDivElement;
  if (advancedToggle && advancedPanel) {
    advancedToggle.addEventListener('click', () => {
      const isVisible = advancedPanel.style.display === 'block';
      advancedPanel.style.display = isVisible ? 'none' : 'block';
      log('‚öôÔ∏è Advanced panel toggled:', !isVisible ? 'visible' : 'hidden');
    });
  }
  
  // Confirm button handler - use capture phase to ensure it fires first
  const confirmBtn = modal.querySelector('#confirmSpot') as HTMLButtonElement;
  if (confirmBtn) {
    confirmBtn.addEventListener('click', (e) => {
            e.stopPropagation();
      e.preventDefault();
      
      // üéØ BATCH 2: Read selected capture mode (user may have overridden auto-detection)
      const selectedMode = (modal.querySelector('input[name="captureMode"]:checked') as HTMLInputElement)?.value || 'header';
      const finalPositionBased = selectedMode === 'position';
      log('üìç Final capture mode (user selected):', finalPositionBased ? 'Position-based' : 'Header-based');
      
      modal.remove();
      
      // ‚è≥ WAIT 2 SECONDS FOR JS FRAMEWORKS TO RENDER
      log('‚è≥ Waiting 2s for JavaScript to render...');
      
      setTimeout(() => {
        // üéØ BATCH 1: Generate selectors for excluded elements
        const excludedSelectors: string[] = [];
        excludedElements.forEach(el => {
          const selector = generateSelector(el);
          excludedSelectors.push(selector);
        });
        console.log('üéØ Generated', excludedSelectors.length, 'exclusion selectors');
        
        // ‚ú® SANITIZE HTML BEFORE STORING (after JS renders)
        // Pass excluded elements so they can be removed from saved HTML
        const cleanedHTML = sanitizeHTML(target, excludedElements);
        log('üßπ HTML sanitized, length:', cleanedHTML.length, 'chars');
        
        // üéØ BATCH 2: Extract first heading for self-healing fallback
        // üîß FIX: Extract from LIVE DOM (target), not sanitized HTML
        // Amazon and other sites inject text via JS that cloneNode doesn't capture
        // Live DOM has the rendered text, sanitized clone may have empty spans
        const heading = target.querySelector(`
          h1, h2, h3, h4, caption,
          [class*="heading"], [class*="title"], [class*="header"],
          [data-testid*="heading"], [data-testid*="title"]
        `);
        // Limit to 100 chars to avoid exceeding sync storage quota (8KB per item)
        const rawHeading = heading?.textContent?.trim() || null;
        const headingFingerprint = rawHeading ? rawHeading.substring(0, 100) : null;
        // Always log for debugging - even if null
        log('üîñ Extracted heading fingerprint:', headingFingerprint || 'NULL (no h1-h4 found)');
        
        // üéØ BATCH 2: Use finalPositionBased (user's selection from Advanced panel)
        // Don't recalculate - respect user's choice even if it conflicts with heading presence
        log('üìç Using final capture mode:', finalPositionBased ? 'Position-based' : 'Header-based');
        
        // Extract domain for favicon
        const domain = new URL(window.location.href).hostname;
        const faviconUrl = `https://www.google.com/s2/favicons?sz=64&domain=${domain}`;
        
        const component = {
          id: crypto.randomUUID(),
          url: window.location.href,
          selector: selector,
          name: name,
          html_cache: cleanedHTML,
          last_refresh: new Date().toISOString(),
          created_at: new Date().toISOString(), // Track creation time separately from refresh
          favicon: faviconUrl
        };
        
        log('üì¶ Component object created:', component.id);

        // Save with hybrid storage model
        log('üíæ Attempting hybrid save (sync + local)...');
        
        // Prepare metadata for sync storage (includes selector for cross-device refresh)
        const metadata = {
          id: component.id,
          url: component.url,
          name: component.name,
          favicon: component.favicon,
          customLabel: undefined,  // New captures don't have custom labels yet
          selector: component.selector,
          headingFingerprint: headingFingerprint,  // üéØ BATCH 2: Auto-extracted for self-healing
          positionBased: finalPositionBased  // üéØ BATCH 2: Use user's final selection from Advanced panel
          // üéØ FIX: excludedSelectors stored in LOCAL only (too large for sync quota)
        };
        console.log('üíæ Storing metadata in sync storage (~300 bytes), exclusions in local storage');

        // üéØ Playground capture: save to storage.local ONLY (avoid sync quota pressure)
        if (isPlaygroundPage) {
          const playgroundKey = `playground-${component.id}`;
          const playgroundData = {
            [playgroundKey]: {
              id: component.id,
              name: metadata.name,
              url: metadata.url,
              favicon: metadata.favicon,
              selector: metadata.selector,
              html_cache: component.html_cache,
              last_refresh: component.last_refresh,
              created_at: component.created_at,
              isPlaygroundCapture: true
            }
          };

          chrome.storage.local.set(playgroundData, () => {
            if (chrome.runtime.lastError) {
              console.error('‚ùå Playground save failed:', chrome.runtime.lastError);
              showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
              return;
            }

            log('‚úÖ Playground capture saved to local storage:', playgroundKey);

            // Update beacon: capture completed
            const beacon = document.getElementById('sb-onboarding-beacon');
            if (beacon) {
              beacon.dataset.stage = 'completed';
              log('üéØ Playground beacon updated: data-stage=completed');
            }

            // Auto-dismiss the confirmation modal on playground ‚Äî "You did it!" card takes over
            const confirmModal = document.getElementById('spotboard-capture-confirmation');
            if (confirmModal) confirmModal.remove();

            // Clear visuals and show notification
            target.style.outline = '';
            target.style.cursor = '';
            lockedElement = null;
            resetExclusions();

            // Skip notification on playground ‚Äî "You did it!" card in sandbox.html takes over
            toggleCapture(false);

            // GA4: Track playground capture
            chrome.runtime.sendMessage({
              type: 'GA4_EVENT',
              eventName: 'capture_completed',
              params: {
                url_domain: 'playground',
                capture_mode: finalPositionBased ? 'position' : 'selector',
                is_playground: true
              }
            });
          });
          return; // Skip normal sync+local save flow
        }

        // NEW: Save with per-component key instead of array
        const syncKey = `comp-${component.id}`;
        const syncData = {
          [syncKey]: {
            id: component.id,
            name: metadata.name,
            url: metadata.url,
            favicon: metadata.favicon,
            customLabel: metadata.customLabel,
            selector: metadata.selector,
            headingFingerprint: metadata.headingFingerprint,
            positionBased: finalPositionBased, // üéØ BATCH 2: User's final selection from Advanced panel
            excludedSelectors: excludedSelectors, // IMPORTANT: Sync for cross-device!
            last_refresh: component.last_refresh,
            created_at: component.created_at // Track creation time for analytics
          }
        };

        log('üíæ Saving component with key:', syncKey);

        // Save metadata to sync storage with per-component key
        chrome.storage.sync.set(syncData, () => {
            if (chrome.runtime.lastError) {
              console.error('‚ùå Sync storage set error:', chrome.runtime.lastError);
              showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
              return;
            }

            log('‚úÖ Metadata saved to sync storage');

            // Save full component data to local storage (including selector)
            chrome.storage.local.get(['componentsData'], (localResult) => {
              if (chrome.runtime.lastError) {
                console.error('‚ùå Local storage GET error:', chrome.runtime.lastError);
                showStyledNotification(`‚ùå Save failed: Could not read local storage`, 'error');
                return;
              }

              const localData: Record<string, any> = localResult.componentsData || {};

              const dataToSave = {
                selector: component.selector,
                html_cache: component.html_cache,
                last_refresh: component.last_refresh,
                excludedSelectors: excludedSelectors
              };

              localData[component.id] = dataToSave;

              chrome.storage.local.set({ componentsData: localData }, () => {
                if (chrome.runtime.lastError) {
                  console.error('‚ùå Local storage set error:', chrome.runtime.lastError);
                  showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
                  return;
                }

                // üîç VERIFICATION: Read back to confirm save succeeded
                chrome.storage.local.get(['componentsData'], (verifyResult: { componentsData?: Record<string, any> }) => {
                  const savedData = verifyResult.componentsData?.[component.id];
                  if (!savedData || !savedData.html_cache) {
                    console.error('‚ùå VERIFICATION FAILED: Component not found in local storage after save!');
                    console.error('   Component ID:', component.id);
                    console.error('   Keys in storage:', Object.keys(verifyResult.componentsData || {}));

                    // üéØ BATCH 5: Track capture failure
                    chrome.runtime.sendMessage({
                      type: 'GA4_EVENT',
                      eventName: 'capture_failed',
                      params: {
                        url_domain: new URL(window.location.href).hostname,
                        error_type: 'storage_verification_failed',
                        selector_type: selector.includes('#') ? 'id' : selector.includes('[data-') ? 'data-attr' : 'class'
                      }
                    }, (response) => {
                      if (response?.success) {
                        console.log('üìä GA4: capture_failed tracked');
                      }
                    });

                    showStyledNotification(`‚ö†Ô∏è Warning: Save may have failed - please refresh dashboard`, 'error');
                  } else {
                    // GA4: Track first capture (one-time event)
                    console.log('üîç DEBUG: Verification passed, checking GA4 first_capture...');
                    chrome.storage.local.get(['firstCaptureCompleted'], (captureFlags) => {
                      console.log('üîç DEBUG: firstCaptureCompleted flag:', captureFlags.firstCaptureCompleted);
                      if (!captureFlags.firstCaptureCompleted) {
                        console.log('üîç DEBUG: Sending first_capture message to background...');
                        chrome.runtime.sendMessage({
                          type: 'GA4_EVENT',
                          eventName: 'first_capture',
                          params: {
                            url_domain: new URL(window.location.href).hostname,
                            capture_mode: finalPositionBased ? 'position' : 'selector'
                          }
                        }, (response) => {
                          console.log('üîç DEBUG: Background response:', response);
                        });
                        chrome.storage.local.set({ firstCaptureCompleted: true });
                        console.log('üìä GA4: first_capture sent');
                      } else {
                        console.log('üîç DEBUG: first_capture already tracked, skipping');
                      }
                    });

                    // üìä GA4: Track every capture (not just first)
                    chrome.runtime.sendMessage({
                      type: 'GA4_EVENT',
                      eventName: 'capture_completed',
                      params: {
                        url_domain: new URL(window.location.href).hostname,
                        capture_mode: finalPositionBased ? 'position' : 'selector',
                        has_exclusions: excludedSelectors.length > 0
                      }
                    });

                    log('‚úÖ Full data saved to local storage');
                    log('‚úÖ Component saved successfully (hybrid)!');

                    // Clear green flash and unlock
                    target.style.outline = '';
                    target.style.cursor = '';
                    lockedElement = null;
                    resetExclusions();

                    showStyledNotification(`‚úÖ Spotted: ${name}`, 'success');
                    toggleCapture(false);
                  }
                });
              });
            });
          });
      }, 2000);
    }, true); // Use capture phase
  }
  
  // Cancel button handler - use capture phase
  const cancelBtn = modal.querySelector('#cancelSpot') as HTMLButtonElement;
  if (cancelBtn) {
    cancelBtn.addEventListener('click', (e) => {
            e.stopPropagation();
      e.preventDefault();
      modal.remove();
      // Clear green flash and unlock
      target.style.outline = '';
      target.style.cursor = '';
      lockedElement = null;
      resetExclusions();
      // üìä GA4: Track cancellation
      chrome.runtime.sendMessage({
        type: 'GA4_EVENT',
        eventName: 'capture_cancelled',
        params: {
          url_domain: new URL(window.location.href).hostname,
          had_preview: true,
          had_exclusions: excludedElements.length > 0
        }
      });
            toggleCapture(false);
    }, true); // Use capture phase
  }
  
  // Handle Escape key to close modal
  const escapeHandler = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
            modal.remove();
      target.style.outline = '';
      target.style.cursor = '';
      lockedElement = null;
      resetExclusions();
      // üìä GA4: Track cancellation via Escape
      chrome.runtime.sendMessage({
        type: 'GA4_EVENT',
        eventName: 'capture_cancelled',
        params: {
          url_domain: new URL(window.location.href).hostname,
          had_preview: true,
          had_exclusions: excludedElements.length > 0
        }
      });
            document.removeEventListener('keydown', escapeHandler);
    }
  };
  document.addEventListener('keydown', escapeHandler);
}

// 4. Escape Key Handler
function handleKeydown(event: KeyboardEvent) {
  if (event.key === "Escape" && isCapturing) {
    toggleCapture(false);
    alert("‚ùå Capture Cancelled");
  }
}

// Main Toggle Logic

// Show persistent yellow banner when capture mode is active
function showCaptureBanner() {
  // Don't create duplicate
  if (document.getElementById('spotboard-capture-banner')) return;
  
  const banner = document.createElement('div');
  banner.id = 'spotboard-capture-banner';
  banner.setAttribute('data-spotboard-ignore', 'true'); // Mark as non-capturable
  banner.style.cssText = `
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    background: #FFFF00 !important;
    color: #000000 !important;
    padding: 10px 20px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    gap: 12px !important;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
    font-size: 14px !important;
    font-weight: 400 !important;
    z-index: 2147483646 !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
    pointer-events: none !important;
  `;
  
  banner.innerHTML = `
    <img src="${chrome.runtime.getURL('icon-16.png')}" style="width: 20px; height: 20px; pointer-events: none;">
    <span style="pointer-events: none;"><strong style="font-weight: 700 !important;">Capture Mode Active</strong> - Click on any content you want to add to your board</span>
    <span style="margin-left: auto; pointer-events: none;">Press <span style="padding: 2px 6px; background: rgba(0, 0, 0, 0.15); border-radius: 3px; font-family: monospace; font-size: 12px;">[Esc]</span> to cancel capture</span>
  `;
  
  document.body.appendChild(banner);
}

function toggleCapture(forceState?: boolean) {
  isCapturing = forceState !== undefined ? forceState : !isCapturing;
  
  if (isCapturing) {
    log("üü¢ Capture Mode: ON");
    document.addEventListener('mouseover', handleHover, true);
    document.addEventListener('mouseout', handleExit, true);
    document.addEventListener('click', handleClick, true);
    document.addEventListener('keydown', handleKeydown, true);
    
    // üéØ Show persistent yellow banner at top
    showCaptureBanner();

    // Update playground beacon: capture mode activated
    if (isPlaygroundPage) {
      const beacon = document.getElementById('sb-onboarding-beacon');
      if (beacon) {
        beacon.dataset.stage = 'capturing';
        log('üéØ Playground beacon updated: data-stage=capturing');
      }
    }
  } else {
    log("üî¥ Capture Mode: OFF");
    document.removeEventListener('mouseover', handleHover, true);
    document.removeEventListener('mouseout', handleExit, true);
    document.removeEventListener('click', handleClick, true);
    document.removeEventListener('keydown', handleKeydown, true);
    
    // Force cleanup all visuals
    document.querySelectorAll('*').forEach(el => {
      (el as HTMLElement).style.outline = '';
      (el as HTMLElement).style.cursor = '';
    });
    
    // Remove capture banner
    const banner = document.getElementById('spotboard-capture-banner');
    if (banner) banner.remove();
  }
}

// Message Listener
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // Respond to ping to confirm content script is loaded
  if (request.type === 'PING') {
    sendResponse({ status: 'ready' });
    return true; // Keep message channel open for async response
  }
  
  if (request.message === "TOGGLE_CAPTURE" || request.type === "TOGGLE_CAPTURE") {
    toggleCapture();
  }
});