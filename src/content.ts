console.log("üöÄ ComponentCanvas: Content Script Loaded");

// Debug mode - set to true for detailed logging
const DEBUG = false;
const log = (...args: any[]) => DEBUG && console.log(...args);

let isCapturing = false;


// Check if an ID looks auto-generated and should be avoided
function isAutoGeneratedId(id: string): boolean {
  if (!id) return false;
  
  // Patterns for auto-generated IDs:
  // - Starts with "yui_" (Yahoo UI framework)
  // - Contains long sequences of numbers (10+ digits, likely timestamps)
  // - Contains UUID patterns (hex-hex-hex-hex-hex)
  // - React/Vue generated IDs
  const patterns = [
    /^yui_/i,                    // Yahoo UI: yui_3_18_1_1_1764458743229_1180
    /\d{10,}/,                   // Long numbers (timestamps): id_1234567890123
    /[a-f0-9]{8}-[a-f0-9]{4}/i,  // UUID-like: 12345678-1234-...
    /^react-/i,                  // React: react-select-2-option-1
    /^__BVID__/i,                // Vue Bootstrap
    /^ember\d+/i                 // Ember: ember123
  ];
  
  return patterns.some(pattern => pattern.test(id));
}

// Generate a specific CSS selector for an element
function generateSelector(element: HTMLElement): string {
  log('üéØ Starting selector generation for:', element.tagName, element.className);
  
  // Priority 1: ID (only if NOT auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    log('‚úÖ Found stable ID selector:', `#${element.id}`);
    return `#${element.id}`;
  } else if (element.id && isAutoGeneratedId(element.id)) {
    log('‚ö†Ô∏è Skipping auto-generated ID:', element.id);
  }
  
  // Build base selector: tag + classes + data attributes
  let baseSelector = buildBaseSelector(element);
  log('üìã Base selector:', baseSelector);
  
  // Check if selector is unique on the page
  const matches = document.querySelectorAll(baseSelector);
  log(`üîç Base selector matches ${matches.length} elements`);
  
  if (matches.length === 1) {
    log('üéØ Generated unique selector:', baseSelector);
    return baseSelector;
  }
  
  log(`‚ö†Ô∏è Selector "${baseSelector}" matches ${matches.length} elements, adding context...`);
  
  // For very generic selectors, go straight to path-based approach
  if (baseSelector === element.tagName.toLowerCase() && matches.length > 50) {
    log('üî§ Element is too generic, skipping to path-based selector...');
  }
  
  // Not unique - try adding nth-of-type
  const parent = element.parentElement;
  if (parent) {
    const siblings = Array.from(parent.children).filter(
      child => child.matches(baseSelector.split('[')[0]) // Match by tag.class without attrs
    );
    const index = siblings.indexOf(element) + 1;
    
    if (index > 0) {
      const nthSelector = `${baseSelector}:nth-of-type(${index})`;
      const nthMatches = document.querySelectorAll(nthSelector);
      log(`üîç nth-of-type selector matches ${nthMatches.length} elements`);
      
      if (nthMatches.length === 1) {
        log('üéØ Generated unique selector with nth-of-type:', nthSelector);
        return nthSelector;
      }
    }
  }
  
  // Still not unique - build path from unique ancestor
  const pathSelector = buildPathFromUniqueAncestor(element, baseSelector);
  if (pathSelector) {
    log('üéØ Generated unique selector with ancestor path:', pathSelector);
    return pathSelector;
  }
  
  // Last resort: return base selector (fingerprint will catch mismatches)
  log('‚ö†Ô∏è Could not make selector unique, using:', baseSelector);
  return baseSelector;
}

// Helper: Escape special characters in CSS class names (for Tailwind etc.)
function escapeCSSClass(className: string): string {
  // Escape special characters that are invalid in CSS selectors
  // Common in Tailwind: : / [ ] ( ) @ ! # $ % ^ & * + = , . < > ? ~ 
  return className
    .replace(/:/g, '\\:')   // xl:mt-0 -> xl\:mt-0
    .replace(/\//g, '\\/')  // w-3/12 -> w-3\/12
    .replace(/\[/g, '\\[')  // [&_svg] -> \[&_svg\]
    .replace(/\]/g, '\\]')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)')
    .replace(/\./g, '\\.')  // Important: escape dots in class names
    .replace(/#/g, '\\#')
    .replace(/!/g, '\\!')
    .replace(/@/g, '\\@')
    .replace(/\$/g, '\\$')
    .replace(/%/g, '\\%')
    .replace(/\^/g, '\\^')
    .replace(/&/g, '\\&')
    .replace(/\*/g, '\\*')
    .replace(/\+/g, '\\+')
    .replace(/=/g, '\\=')
    .replace(/,/g, '\\,')
    .replace(/</g, '\\<')
    .replace(/>/g, '\\>')
    .replace(/\?/g, '\\?')
    .replace(/~/g, '\\~');
}

// Helper: Build base selector (tag + classes + data attrs)
function buildBaseSelector(element: HTMLElement): string {
  let selector = element.tagName.toLowerCase();
  
  // Add classes (max 3 to avoid overly specific selectors)
  if (element.classList.length > 0) {
    const classes = Array.from(element.classList)
      .filter(c => !c.includes('hover') && !c.includes('active')) // Skip state classes
      .slice(0, 3)
      .map(c => escapeCSSClass(c)); // ‚ú® ESCAPE SPECIAL CHARACTERS
    if (classes.length > 0) {
      selector += '.' + classes.join('.');
    }
  }
  
  // Add key data attributes (very useful for modern sites like BBC)
  const usefulAttrs = ['data-testid', 'data-component', 'data-section', 'data-module', 'data-type', 'data-t', 'role'];
  for (const attr of usefulAttrs) {
    if (element.hasAttribute(attr)) {
      const value = element.getAttribute(attr);
      selector += `[${attr}="${value}"]`;
      break; // One data attr is usually enough
    }
  }
  
  return selector;
}

// Helper: Walk up DOM to find unique ancestor, build path
function buildPathFromUniqueAncestor(element: HTMLElement, baseSelector: string): string | null {
  let current = element.parentElement;
  const pathParts: string[] = [baseSelector];
  
  while (current && current.tagName !== 'BODY' && current.tagName !== 'HTML') {
    // Check if this ancestor has an ID
    if (current.id) {
      pathParts.unshift(`#${current.id}`);
      const fullPath = pathParts.join(' > ');
      if (document.querySelectorAll(fullPath).length === 1) {
        return fullPath;
      }
    }
    
    // Check for unique data attributes on ancestor
    const usefulAttrs = ['data-testid', 'data-component', 'data-section', 'data-module', 'data-type'];
    for (const attr of usefulAttrs) {
      if (current.hasAttribute(attr)) {
        const ancestorSelector = `${current.tagName.toLowerCase()}[${attr}="${current.getAttribute(attr)}"]`;
        pathParts.unshift(ancestorSelector);
        const fullPath = pathParts.join(' > ');
        if (document.querySelectorAll(fullPath).length === 1) {
          return fullPath;
        }
        pathParts.shift(); // Remove if not unique
      }
    }
    
    // Add parent to path and continue up
    const parentSelector = buildBaseSelector(current);
    pathParts.unshift(parentSelector);
    
    // Check if path is now unique
    const fullPath = pathParts.join(' > ');
    if (document.querySelectorAll(fullPath).length === 1) {
      return fullPath;
    }
    
    // Limit depth to avoid overly long selectors
    if (pathParts.length > 4) {
      break;
    }
    
    current = current.parentElement;
  }
  
  return null;
}

// 1. Hover Handler (The Red Box)
function handleHover(event: MouseEvent) {
  if (!isCapturing) return;
  const target = event.target as HTMLElement;
  
  // Visuals
  target.style.setProperty('outline', '5px solid red', 'important');
  target.style.cursor = 'crosshair';
  
  event.stopPropagation();
}

// 2. Exit Handler (Cleanup)
function handleExit(event: MouseEvent) {
  if (!isCapturing) return;
  const target = event.target as HTMLElement;
  target.style.outline = '';
}

// 3. Click Handler (The Save)
// Sanitize captured HTML - remove capture artifacts
function sanitizeHTML(element: HTMLElement): string {
  // Clone the element to avoid modifying the original
  const clone = element.cloneNode(true) as HTMLElement;
  
  // Remove all capture-related inline styles from clone and descendants
  const allElements = [clone, ...Array.from(clone.querySelectorAll('*'))];
  
  allElements.forEach(el => {
    if (el instanceof HTMLElement) {
      // Remove cursor styles
      el.style.removeProperty('cursor');
      
      // Remove outline styles (our capture indicators)
      el.style.removeProperty('outline');
      
      // Clean up empty style attributes
      if (el.style.length === 0) {
        el.removeAttribute('style');
      }
    }
  });
  
  return clone.outerHTML;
}

function handleClick(event: MouseEvent) {
  if (!isCapturing) return;
  
  log('üñ±Ô∏è Click detected on:', event.target);
  
  event.preventDefault();
  event.stopPropagation();
  
  const target = event.target as HTMLElement;
  log('üéØ Target element:', target.tagName, target.className);
  
  // Green Flash
  target.style.setProperty('outline', '5px solid #00ff00', 'important');
  
  // Generate smart label using Option 1 strategy
  let name = '';
  
  // Strategy 1: Check if element itself is a heading
  if (/^H[1-6]$/i.test(target.tagName)) {
    const text = target.textContent?.trim();
    if (text) {
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from heading:', name);
    }
  }
  
  // Strategy 2: Look for first heading inside element
  if (!name) {
    const heading = target.querySelector('h1, h2, h3, h4, h5, h6');
    if (heading?.textContent?.trim()) {
      const text = heading.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from child heading:', name);
    }
  }
  
  // Strategy 3: Get first meaningful text (skip empty/whitespace-only nodes)
  if (!name) {
    const walker = document.createTreeWalker(
      target,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          const text = node.textContent?.trim();
          return text && text.length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      }
    );
    
    const firstTextNode = walker.nextNode();
    if (firstTextNode?.textContent?.trim()) {
      const text = firstTextNode.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from first text:', name);
    }
  }
  
  // Strategy 4: Fallback to generic label
  if (!name) {
    name = `Component from ${window.location.hostname}`;
    log('üìù Name fallback:', name);
  }
  
  log('üè∑Ô∏è Final name:', name);
  
  const selector = generateSelector(target); // Smart selector for refresh
  log('üéØ Final selector:', selector);
  
  // ‚ú® SANITIZE HTML BEFORE STORING
  const cleanedHTML = sanitizeHTML(target);
  log('üßπ HTML sanitized, length:', cleanedHTML.length, 'chars');
  
  const component = {
    id: crypto.randomUUID(),
    url: window.location.href,
    selector: selector,
    name: name,
    html_cache: cleanedHTML,
    last_refresh: new Date().toISOString()
  };
  
  log('üì¶ Component object created:', component.id);

  // Save
  log('üíæ Attempting to save to chrome.storage.local...');
  chrome.storage.local.get(['components'], (result) => {
    const existingCount = (result.components as any[])?.length || 0;
    log('üì• Storage retrieved, existing components:', existingCount);
    
    if (chrome.runtime.lastError) {
      console.error('‚ùå Chrome storage error:', chrome.runtime.lastError);
      alert(`‚ùå Save failed: ${chrome.runtime.lastError.message}`);
      return;
    }
    
    const list = Array.isArray(result.components) ? result.components : [];
    list.push(component);
    log('üìù Updated list length:', list.length);
    
    chrome.storage.local.set({ components: list }, () => {
      if (chrome.runtime.lastError) {
        console.error('‚ùå Chrome storage set error:', chrome.runtime.lastError);
        alert(`‚ùå Save failed: ${chrome.runtime.lastError.message}`);
        return;
      }
      
      log('‚úÖ Component saved successfully!');
      
      // Clear green flash
      target.style.outline = '';
      target.style.cursor = '';
      
      alert(`‚úÖ Saved: ${name}`);
      toggleCapture(false); // Turn off after save
    });
  });
}

// 4. Escape Key Handler
function handleKeydown(event: KeyboardEvent) {
  if (event.key === "Escape" && isCapturing) {
    toggleCapture(false);
    alert("‚ùå Capture Cancelled");
  }
}

// Main Toggle Logic
function toggleCapture(forceState?: boolean) {
  isCapturing = forceState !== undefined ? forceState : !isCapturing;
  
  if (isCapturing) {
    log("üü¢ Capture Mode: ON");
    document.addEventListener('mouseover', handleHover, true);
    document.addEventListener('mouseout', handleExit, true);
    document.addEventListener('click', handleClick, true);
    document.addEventListener('keydown', handleKeydown, true);
  } else {
    log("üî¥ Capture Mode: OFF");
    document.removeEventListener('mouseover', handleHover, true);
    document.removeEventListener('mouseout', handleExit, true);
    document.removeEventListener('click', handleClick, true);
    document.removeEventListener('keydown', handleKeydown, true);
    
    // Force cleanup all visuals
    document.querySelectorAll('*').forEach(el => {
      (el as HTMLElement).style.outline = '';
      (el as HTMLElement).style.cursor = '';
    });
  }
}

// Message Listener
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.message === "TOGGLE_CAPTURE" || request.type === "TOGGLE_CAPTURE") {
    toggleCapture();
  }
});