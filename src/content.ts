console.log("üöÄ SpotBoard: Content Script Loaded");

// Debug mode - set to true for detailed logging
const DEBUG = false;
const log = (...args: any[]) => DEBUG && console.log(...args);

let isCapturing = false;


// Check if an ID looks auto-generated and should be avoided
function isAutoGeneratedId(id: string): boolean {
  if (!id) return false;
  
  // Patterns for auto-generated IDs:
  // - Starts with "yui_" (Yahoo UI framework)
  // - Contains long sequences of numbers (10+ digits, likely timestamps)
  // - Contains UUID patterns (hex-hex-hex-hex-hex)
  // - React/Vue generated IDs
  const patterns = [
    /^yui_/i,                    // Yahoo UI: yui_3_18_1_1_1764458743229_1180
    /\d{10,}/,                   // Long numbers (timestamps): id_1234567890123
    /[a-f0-9]{8}-[a-f0-9]{4}/i,  // UUID-like: 12345678-1234-...
    /^react-/i,                  // React: react-select-2-option-1
    /^__BVID__/i,                // Vue Bootstrap
    /^ember\d+/i                 // Ember: ember123
  ];
  
  return patterns.some(pattern => pattern.test(id));
}

// Generate a specific CSS selector for an element
function generateSelector(element: HTMLElement): string {
  log('üéØ Starting selector generation for:', element.tagName, element.className);
  
  // Priority 1: ID (only if NOT auto-generated)
  if (element.id && !isAutoGeneratedId(element.id)) {
    log('‚úÖ Found stable ID selector:', `#${element.id}`);
    return `#${element.id}`;
  } else if (element.id && isAutoGeneratedId(element.id)) {
    log('‚ö†Ô∏è Skipping auto-generated ID:', element.id);
  }
  
  // Build base selector: tag + classes + data attributes
  let baseSelector = buildBaseSelector(element);
  log('üìã Base selector:', baseSelector);
  
  // Check if selector is unique on the page
  const matches = document.querySelectorAll(baseSelector);
  log(`üîç Base selector matches ${matches.length} elements`);
  
  if (matches.length === 1) {
    log('üéØ Generated unique selector:', baseSelector);
    return baseSelector;
  }
  
  log(`‚ö†Ô∏è Selector "${baseSelector}" matches ${matches.length} elements, adding context...`);
  
  // For very generic selectors, go straight to path-based approach
  if (baseSelector === element.tagName.toLowerCase() && matches.length > 50) {
    log('üî§ Element is too generic, skipping to path-based selector...');
  }
  
  // Not unique - try adding nth-of-type
  const parent = element.parentElement;
  if (parent) {
    const siblings = Array.from(parent.children).filter(
      child => child.matches(baseSelector.split('[')[0]) // Match by tag.class without attrs
    );
    const index = siblings.indexOf(element) + 1;
    
    if (index > 0) {
      const nthSelector = `${baseSelector}:nth-of-type(${index})`;
      const nthMatches = document.querySelectorAll(nthSelector);
      log(`üîç nth-of-type selector matches ${nthMatches.length} elements`);
      
      if (nthMatches.length === 1) {
        log('üéØ Generated unique selector with nth-of-type:', nthSelector);
        return nthSelector;
      }
    }
  }
  
  // Still not unique - build path from unique ancestor
  const pathSelector = buildPathFromUniqueAncestor(element, baseSelector);
  if (pathSelector) {
    log('üéØ Generated unique selector with ancestor path:', pathSelector);
    return pathSelector;
  }
  
  // Last resort: return base selector (fingerprint will catch mismatches)
  log('‚ö†Ô∏è Could not make selector unique, using:', baseSelector);
  return baseSelector;
}

// Helper: Escape special characters in CSS class names (for Tailwind etc.)
function escapeCSSClass(className: string): string {
  // Escape special characters that are invalid in CSS selectors
  // Common in Tailwind: : / [ ] ( ) @ ! # $ % ^ & * + = , . < > ? ~ 
  return className
    .replace(/:/g, '\\:')   // xl:mt-0 -> xl\:mt-0
    .replace(/\//g, '\\/')  // w-3/12 -> w-3\/12
    .replace(/\[/g, '\\[')  // [&_svg] -> \[&_svg\]
    .replace(/\]/g, '\\]')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)')
    .replace(/\./g, '\\.')  // Important: escape dots in class names
    .replace(/#/g, '\\#')
    .replace(/!/g, '\\!')
    .replace(/@/g, '\\@')
    .replace(/\$/g, '\\$')
    .replace(/%/g, '\\%')
    .replace(/\^/g, '\\^')
    .replace(/&/g, '\\&')
    .replace(/\*/g, '\\*')
    .replace(/\+/g, '\\+')
    .replace(/=/g, '\\=')
    .replace(/,/g, '\\,')
    .replace(/</g, '\\<')
    .replace(/>/g, '\\>')
    .replace(/\?/g, '\\?')
    .replace(/~/g, '\\~');
}

// Helper: Build base selector (tag + classes + data attrs)
function buildBaseSelector(element: HTMLElement): string {
  let selector = element.tagName.toLowerCase();
  
  // Add classes (max 3 to avoid overly specific selectors)
  if (element.classList.length > 0) {
    const classes = Array.from(element.classList)
      .filter(c => !c.includes('hover') && !c.includes('active')) // Skip state classes
      .slice(0, 3)
      .map(c => escapeCSSClass(c)); // ‚ú® ESCAPE SPECIAL CHARACTERS
    if (classes.length > 0) {
      selector += '.' + classes.join('.');
    }
  }
  
  // Add key data attributes (very useful for modern sites like BBC)
  const usefulAttrs = ['data-testid', 'data-component', 'data-section', 'data-module', 'data-type', 'data-t', 'role'];
  for (const attr of usefulAttrs) {
    if (element.hasAttribute(attr)) {
      const value = element.getAttribute(attr);
      selector += `[${attr}="${value}"]`;
      break; // One data attr is usually enough
    }
  }
  
  return selector;
}

// Helper: Walk up DOM to find unique ancestor, build path
function buildPathFromUniqueAncestor(element: HTMLElement, baseSelector: string): string | null {
  let current = element.parentElement;
  const pathParts: string[] = [baseSelector];
  
  while (current && current.tagName !== 'BODY' && current.tagName !== 'HTML') {
    // Check if this ancestor has an ID
    if (current.id) {
      pathParts.unshift(`#${current.id}`);
      const fullPath = pathParts.join(' > ');
      if (document.querySelectorAll(fullPath).length === 1) {
        return fullPath;
      }
    }
    
    // Check for unique data attributes on ancestor
    const usefulAttrs = ['data-testid', 'data-component', 'data-section', 'data-module', 'data-type'];
    for (const attr of usefulAttrs) {
      if (current.hasAttribute(attr)) {
        const ancestorSelector = `${current.tagName.toLowerCase()}[${attr}="${current.getAttribute(attr)}"]`;
        pathParts.unshift(ancestorSelector);
        const fullPath = pathParts.join(' > ');
        if (document.querySelectorAll(fullPath).length === 1) {
          return fullPath;
        }
        pathParts.shift(); // Remove if not unique
      }
    }
    
    // Add parent to path and continue up
    const parentSelector = buildBaseSelector(current);
    pathParts.unshift(parentSelector);
    
    // Check if path is now unique
    const fullPath = pathParts.join(' > ');
    if (document.querySelectorAll(fullPath).length === 1) {
      return fullPath;
    }
    
    // Limit depth to avoid overly long selectors
    if (pathParts.length > 4) {
      break;
    }
    
    current = current.parentElement;
  }
  
  return null;
}

// 1. Hover Handler (The Red Box)
function handleHover(event: MouseEvent) {
  if (!isCapturing) return;
  const target = event.target as HTMLElement;
  
  // Visuals
  target.style.setProperty('outline', '5px solid red', 'important');
  target.style.cursor = 'crosshair';
  
  event.stopPropagation();
}

// 2. Exit Handler (Cleanup)
function handleExit(event: MouseEvent) {
  if (!isCapturing) return;
  const target = event.target as HTMLElement;
  target.style.outline = '';
}

// 3. Click Handler (The Save)
// Sanitize captured HTML - remove capture artifacts
// Show styled notification modal instead of alert
function showStyledNotification(message: string, type: 'success' | 'error' = 'success') {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999999;
  `;
  
  const modalContent = document.createElement('div');
  const bgColor = type === 'success' ? '#2d3748' : '#742a2a';
  modalContent.style.cssText = `
    background: ${bgColor};
    color: white;
    padding: 24px;
    border-radius: 8px;
    max-width: 400px;
    width: 90%;
    text-align: center;
  `;
  
  modalContent.innerHTML = `
    <div style="font-size: 16px; margin-bottom: 20px; line-height: 1.5;">
      ${message}
    </div>
    <button id="closeNotification" style="width: 100%; padding: 12px; background: #4299e1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">
      OK
    </button>
  `;
  
  modal.appendChild(modalContent);
  document.body.appendChild(modal);
  
  // Close modal handlers
  const closeBtn = modal.querySelector('#closeNotification');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.remove());
  }
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

function sanitizeHTML(element: HTMLElement): string {
  // ‚ú® CRITICAL: Get computed styles BEFORE cloning (must be in DOM)
  // Build a list of elements to remove based on their visibility
  const elementsToRemove: Element[] = [];
  
  // Check the element itself and all descendants
  const allElements = [element, ...Array.from(element.querySelectorAll('*'))];
  
  allElements.forEach(el => {
    if (el instanceof HTMLElement) {
      const styles = window.getComputedStyle(el);
      
      // Extract values for cleaner checks
      const display = styles.display;
      const visibility = styles.visibility;
      const opacity = parseFloat(styles.opacity);
      const position = styles.position;
      const clip = styles.clip;
      const clipPath = styles.clipPath;
      const height = styles.height;
      const width = styles.width;
      
      // Check if element is hidden by CSS
      const isHidden = 
        display === 'none' ||
        visibility === 'hidden' ||
        opacity === 0 ||
        el.hasAttribute('hidden') ||
        (position === 'absolute' && (
          clip.includes('rect(') ||
          clipPath.includes('inset(') ||
          clipPath.includes('circle(') ||
          clipPath.includes('polygon(')
        )) ||
        (height === '0px' && width === '0px');
      
      if (isHidden && el !== element) { // Don't remove the root element
        elementsToRemove.push(el);
      }
    }
  });
  
  // Clone the element AFTER identifying what to remove
  const clone = element.cloneNode(true) as HTMLElement;
  
  // Remove hidden elements from clone (using path to identify them)
  elementsToRemove.forEach(originalEl => {
    // Find corresponding element in clone by creating a unique selector
    const path = getElementPath(originalEl, element);
    const cloneEl = getElementByPath(clone, path);
    if (cloneEl) {
      cloneEl.remove();
    }
  });
  
  // üéØ HIT LIST: Remove known duplicate/hidden elements by class name
  // This fixes BBC's triple-text pattern (MobileValue, DesktopValue, visually-hidden)
  // Note: BBC uses CSS-in-JS class names like "ssrcss-xxx-MobileValue", so we use partial match
  const duplicateSelectors = [
    '.visually-hidden',           // Screen reader text (exact class)
    '.sr-only',                   // Bootstrap screen reader
    '[class*="MobileValue"]',     // BBC mobile duplicate (partial match for CSS-in-JS)
    '[class*="VisuallyHidden"]'   // BBC visually hidden (partial match)
  ];
  duplicateSelectors.forEach(selector => {
    clone.querySelectorAll(selector).forEach(el => el.remove());
  });

  // Remove capture-related inline styles from clone
  const cloneElements = [clone, ...Array.from(clone.querySelectorAll('*'))];
  cloneElements.forEach(el => {
    if (el instanceof HTMLElement) {
      el.style.removeProperty('cursor');
      el.style.removeProperty('outline');
      if (el.style.length === 0) {
        el.removeAttribute('style');
      }
    }
  });
  
  return clone.outerHTML;
}

// Helper: Get path from root to element
function getElementPath(element: Element, root: Element): number[] {
  const path: number[] = [];
  let current = element;
  
  while (current && current !== root) {
    const parent = current.parentElement;
    if (!parent) break;
    
    const index = Array.from(parent.children).indexOf(current);
    path.unshift(index);
    current = parent;
  }
  
  return path;
}

// Helper: Get element from clone using path
function getElementByPath(root: Element, path: number[]): Element | null {
  let current: Element | null = root;
  
  for (const index of path) {
    if (!current) return null;
    current = current.children[index] || null;
  }
  
  return current;
}

function handleClick(event: MouseEvent) {
  if (!isCapturing) return;
  
  log('üñ±Ô∏è Click detected on:', event.target);
  
  event.preventDefault();
  event.stopPropagation();
  
  const target = event.target as HTMLElement;
  log('üéØ Target element:', target.tagName, target.className);
  
  // Green Flash
  target.style.setProperty('outline', '5px solid #00ff00', 'important');
  
  // Generate smart label using Option 1 strategy
  let name = '';
  
  // Strategy 1: Check if element itself is a heading
  if (/^H[1-6]$/i.test(target.tagName)) {
    const text = target.textContent?.trim();
    if (text) {
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from heading:', name);
    }
  }
  
  // Strategy 2: Look for first heading inside element
  if (!name) {
    const heading = target.querySelector('h1, h2, h3, h4, h5, h6');
    if (heading?.textContent?.trim()) {
      const text = heading.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from child heading:', name);
    }
  }
  
  // Strategy 3: Get first meaningful text (skip empty/whitespace-only nodes)
  if (!name) {
    const walker = document.createTreeWalker(
      target,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: (node) => {
          const text = node.textContent?.trim();
          return text && text.length > 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      }
    );
    
    const firstTextNode = walker.nextNode();
    if (firstTextNode?.textContent?.trim()) {
      const text = firstTextNode.textContent.trim();
      name = text.length > 50 ? text.substring(0, 50) + '...' : text;
      log('üìù Name from first text:', name);
    }
  }
  
  // Strategy 4: Fallback to generic label
  if (!name) {
    name = `Component from ${window.location.hostname}`;
    log('üìù Name fallback:', name);
  }
  
  log('üè∑Ô∏è Final name:', name);
  
  const selector = generateSelector(target); // Smart selector for refresh
  log('üéØ Final selector:', selector);
  
  // ‚ú® SANITIZE HTML BEFORE STORING
  const cleanedHTML = sanitizeHTML(target);
  log('üßπ HTML sanitized, length:', cleanedHTML.length, 'chars');
  
  // Extract domain for favicon
  const domain = new URL(window.location.href).hostname;
  const faviconUrl = `https://www.google.com/s2/favicons?sz=64&domain=${domain}`;
  
  const component = {
    id: crypto.randomUUID(),
    url: window.location.href,
    selector: selector,
    name: name,
    html_cache: cleanedHTML,
    last_refresh: new Date().toISOString(),
    favicon: faviconUrl
  };
  
  log('üì¶ Component object created:', component.id);

  // Save with hybrid storage model
  log('üíæ Attempting hybrid save (sync + local)...');
  
  // Prepare metadata for sync storage (includes selector for cross-device refresh)
  const metadata = {
    id: component.id,
    url: component.url,
    name: component.name,
    favicon: component.favicon,
    selector: component.selector  // Essential for refresh on other devices
  };
  
  // Get existing sync data
  chrome.storage.sync.get(['components'], (result) => {
    const existingCount = (result.components as any[])?.length || 0;
    log('üì• Sync storage retrieved, existing components:', existingCount);
    
    if (chrome.runtime.lastError) {
      console.error('‚ùå Chrome storage error:', chrome.runtime.lastError);
      showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
      return;
    }
    
    const metadataList = Array.isArray(result.components) ? result.components : [];
    metadataList.push(metadata);
    log('üìù Updated metadata list length:', metadataList.length);
    
    // Save metadata to sync storage
    chrome.storage.sync.set({ components: metadataList }, () => {
      if (chrome.runtime.lastError) {
        console.error('‚ùå Sync storage set error:', chrome.runtime.lastError);
        showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
        return;
      }
      
      log('‚úÖ Metadata saved to sync storage');
      
      // Save full component data to local storage (including selector)
      chrome.storage.local.get(['componentsData'], (localResult) => {
        const localData: Record<string, any> = localResult.componentsData || {};
        localData[component.id] = {
          selector: component.selector,  // Needed for refresh
          html_cache: component.html_cache,
          last_refresh: component.last_refresh
        };
        
        chrome.storage.local.set({ componentsData: localData }, () => {
          if (chrome.runtime.lastError) {
            console.error('‚ùå Local storage set error:', chrome.runtime.lastError);
            showStyledNotification(`‚ùå Save failed: ${chrome.runtime.lastError.message}`, 'error');
            return;
          }
          
          log('‚úÖ Full data saved to local storage');
          log('‚úÖ Component saved successfully (hybrid)!');
          
          // Clear green flash
          target.style.outline = '';
          target.style.cursor = '';
          
          showStyledNotification(`‚úÖ Saved: ${name}`, 'success');
          toggleCapture(false); // Turn off after save
        });
      });
    });
  });
}

// 4. Escape Key Handler
function handleKeydown(event: KeyboardEvent) {
  if (event.key === "Escape" && isCapturing) {
    toggleCapture(false);
    alert("‚ùå Capture Cancelled");
  }
}

// Main Toggle Logic
function toggleCapture(forceState?: boolean) {
  isCapturing = forceState !== undefined ? forceState : !isCapturing;
  
  if (isCapturing) {
    log("üü¢ Capture Mode: ON");
    document.addEventListener('mouseover', handleHover, true);
    document.addEventListener('mouseout', handleExit, true);
    document.addEventListener('click', handleClick, true);
    document.addEventListener('keydown', handleKeydown, true);
  } else {
    log("üî¥ Capture Mode: OFF");
    document.removeEventListener('mouseover', handleHover, true);
    document.removeEventListener('mouseout', handleExit, true);
    document.removeEventListener('click', handleClick, true);
    document.removeEventListener('keydown', handleKeydown, true);
    
    // Force cleanup all visuals
    document.querySelectorAll('*').forEach(el => {
      (el as HTMLElement).style.outline = '';
      (el as HTMLElement).style.cursor = '';
    });
  }
}

// Message Listener
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.message === "TOGGLE_CAPTURE" || request.type === "TOGGLE_CAPTURE") {
    toggleCapture();
  }
});